<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[JSON-SCHEMA]]></title>
      <url>%2F2017%2F12%2F07%2FJSON-SCHEMA%2F</url>
      <content type="text"><![CDATA[JSON Schema 简单使用在webservice时代开发基于SOAP协议的webservice应用经常会使用到xml，xml schema、DTD的作用非常大，可以用来约束协议中报文格式合法性；相应的在REST服务盛行的时代也JSON也扮演着重要角色，也出现了json schema这样的神器，可以定义json内容的格式类型，废话少说上代码 json schema1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&#123; &quot;$schema&quot;: &quot;http://json-schema.org/draft-04/schema#&quot;, &quot;title&quot;: &quot;User&quot;, &quot;type&quot;: &quot;object&quot;, &quot;properties&quot;: &#123; &quot;firstName&quot;: &#123; &quot;type&quot;: &quot;string&quot; &#125;, &quot;lastName&quot;: &#123; &quot;type&quot;: &quot;string&quot; &#125;, &quot;email&quot;: &#123; &quot;type&quot;: &quot;string&quot;, &quot;pattern&quot;: &quot;^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(\\.[a-zA-Z0-9_-]+)+$&quot; &#125;, &quot;age&quot;: &#123; &quot;type&quot;: &quot;integer&quot;, &quot;minimum&quot;: 0 &#125;, &quot;sex&quot;: &#123; &quot;type&quot;: &quot;string&quot;, &quot;enum&quot;: [ &quot;男&quot;, &quot;女&quot; ] &#125;, &quot;roles&quot;: &#123; &quot;type&quot;: &quot;object&quot;, &quot;properties&quot;: &#123; &quot;name&quot;: &#123; &quot;type&quot;: &quot;string&quot; &#125;, &quot;code&quot;: &#123; &quot;type&quot;: [ &quot;string&quot;, &quot;integer&quot; ] &#125; &#125;, &quot;required&quot;: [ &quot;code&quot; ] &#125;, &quot;permissions&quot;: &#123; &quot;type&quot;: &quot;array&quot;, &quot;minItems&quot;: 1, &quot;items&quot;: &#123; &quot;type&quot;: &quot;object&quot;, &quot;properties&quot;: &#123; &quot;name&quot;: &#123; &quot;type&quot;: &quot;string&quot; &#125;, &quot;code&quot;: &#123; &quot;type&quot;: [ &quot;integer&quot;, &quot;string&quot; ] &#125; &#125;, &quot;required&quot;: [ &quot;code&quot; ] &#125; &#125; &#125;, &quot;required&quot;: [ &quot;firstName&quot;, &quot;age&quot;, &quot;permissions&quot; ]&#125; json 123456789101112131415161718&#123; &quot;firstName&quot;: &quot;abcd&quot;, &quot;lastName&quot;: &quot;adfads&quot;, &quot;sex&quot;: &quot;男&quot;, &quot;email&quot;: &quot;fafaa@dfadfasdf.dddd&quot;, &quot;roles&quot;: &#123; &quot;name&quot;: &quot;ddd&quot; &#125;, &quot;permissions&quot;: [ &#123; &quot;name&quot;: &quot;dddd&quot; &#125;, &#123; &quot;name&quot;: &quot;aaaa&quot;, &quot;code&quot;: &quot;dddf&quot; &#125; ]&#125; pom.xml 12345&lt;dependency&gt; &lt;groupId&gt;com.github.java-json-tools&lt;/groupId&gt; &lt;artifactId&gt;json-schema-validator&lt;/artifactId&gt; &lt;version&gt;2.2.8&lt;/version&gt;&lt;/dependency&gt; java 代码123456789101112131415161718192021222324252627282930313233import com.fasterxml.jackson.databind.JsonNode;import com.github.fge.jackson.JsonNodeReader;import com.github.fge.jsonschema.core.report.ProcessingMessage;import com.github.fge.jsonschema.core.report.ProcessingReport;import com.github.fge.jsonschema.main.JsonSchema;import com.github.fge.jsonschema.main.JsonSchemaFactory;import org.junit.Assert;import org.junit.Test;import java.io.InputStream;import java.util.Iterator;public class JsonSchemaTest &#123; @Test public void test() throws Exception&#123; InputStream resourceAsStream = this.getClass().getResourceAsStream(&quot;/JsonSchema.json&quot;); JsonNode schema = new JsonNodeReader().fromInputStream(resourceAsStream); JsonNode json = new JsonNodeReader().fromInputStream(this.getClass().getResourceAsStream(&quot;/User.json&quot;)); JsonSchemaFactory jsonSchemaFactory = JsonSchemaFactory.byDefault(); JsonSchema jsonSchema = jsonSchemaFactory.getJsonSchema(schema); ProcessingReport report = jsonSchema.validate(json, true); Iterator&lt;ProcessingMessage&gt; iterator = report.iterator(); while (iterator.hasNext())&#123; ProcessingMessage pm = iterator.next(); JsonNode jsonNode = pm.asJson(); System.out.println(jsonNode); &#125; Assert.assertTrue(report.isSuccess()); &#125;&#125; 输出结果123&#123;&quot;level&quot;:&quot;error&quot;,&quot;schema&quot;:&#123;&quot;loadingURI&quot;:&quot;#&quot;,&quot;pointer&quot;:&quot;&quot;&#125;,&quot;instance&quot;:&#123;&quot;pointer&quot;:&quot;&quot;&#125;,&quot;domain&quot;:&quot;validation&quot;,&quot;keyword&quot;:&quot;required&quot;,&quot;message&quot;:&quot;object has missing required properties ([\&quot;age\&quot;])&quot;,&quot;required&quot;:[&quot;age&quot;,&quot;firstName&quot;,&quot;permissions&quot;],&quot;missing&quot;:[&quot;age&quot;]&#125;&#123;&quot;level&quot;:&quot;error&quot;,&quot;schema&quot;:&#123;&quot;loadingURI&quot;:&quot;#&quot;,&quot;pointer&quot;:&quot;/properties/permissions/items&quot;&#125;,&quot;instance&quot;:&#123;&quot;pointer&quot;:&quot;/permissions/0&quot;&#125;,&quot;domain&quot;:&quot;validation&quot;,&quot;keyword&quot;:&quot;required&quot;,&quot;message&quot;:&quot;object has missing required properties ([\&quot;code\&quot;])&quot;,&quot;required&quot;:[&quot;code&quot;],&quot;missing&quot;:[&quot;code&quot;]&#125;&#123;&quot;level&quot;:&quot;error&quot;,&quot;schema&quot;:&#123;&quot;loadingURI&quot;:&quot;#&quot;,&quot;pointer&quot;:&quot;/properties/roles&quot;&#125;,&quot;instance&quot;:&#123;&quot;pointer&quot;:&quot;/roles&quot;&#125;,&quot;domain&quot;:&quot;validation&quot;,&quot;keyword&quot;:&quot;required&quot;,&quot;message&quot;:&quot;object has missing required properties ([\&quot;code\&quot;])&quot;,&quot;required&quot;:[&quot;code&quot;],&quot;missing&quot;:[&quot;code&quot;]&#125; 就这样，so easy ###参考json-schema-validator实现json schema]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[idea-spring-boot-devtools-not-work]]></title>
      <url>%2F2017%2F03%2F02%2Fidea-spring-boot-devtools-not-work%2F</url>
      <content type="text"><![CDATA[java开发中总是会频繁重启应用，非常麻烦，Spring Boot可以利用devtools配置当修改代码时自动重启应用，也可以使用热部署工具jrebel，但是在idea下默认不生效，google后得到答案，idea不会自动编译程序，开启自动编译后发现，在应用运行中也不会自动编译，找到问题原因了，下面来解决它 设置idea 自动编译Settings.. 设置idea 在程序运行中自动编译快捷键 ctrl + alt + shift + / 选择Registry勾选compiler.automake.allow.when.app.running Spring Boot 配置pom.xml1234567891011121314151617181920&lt;dependencies&gt; ... &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt; &lt;plugins&gt; ... &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 重启应用，就可以了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[msys2-here-context-menu-items]]></title>
      <url>%2F2017%2F02%2F28%2Fmsys2-here-context-menu-items%2F</url>
      <content type="text"><![CDATA[register.reg12345678910Windows Registry Editor Version 5.00[HKEY_CURRENT_USER\Software\Classes\Directory\Background\shell\MSYS here\command]@=&quot;C:\\msys64\\msys2.exe bash&quot;[HKEY_CURRENT_USER\Software\Classes\Directory\Background\shell\MINGW64 here\command]@=&quot;C:\\msys64\\mingw64.exe bash&quot;[HKEY_CURRENT_USER\Software\Classes\Directory\Background\shell\MINGW32 here\command]@=&quot;C:\\msys64\\mingw32.exe bash&quot; unregister.reg12345Windows Registry Editor Version 5.00[-HKEY_CURRENT_USER\Software\Classes\Directory\Background\shell\MSYS here][-HKEY_CURRENT_USER\Software\Classes\Directory\Background\shell\MINGW64 here][-HKEY_CURRENT_USER\Software\Classes\Directory\Background\shell\MINGW32 here]]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[nginx upgrade & add module]]></title>
      <url>%2F2016%2F12%2F22%2Fnginx-upgrade%2F</url>
      <content type="text"><![CDATA[nginx upgrade &amp; add module目标 升级nginx版本 1.10.1 –&gt; 1.10.2 添加缓存模块 添加文件上传模块和上传进度模块 准备工作查看 nginx 已安装模块12$nginx -V--prefix=/etc/nginx --sbin-path=/usr/sbin/nginx --modules-path=/usr/lib64/nginx/modules --conf-path=/etc/nginx/nginx.conf --error-log-path=/var/log/nginx/error.log --http-log-path=/var/log/nginx/access.log --pid-path=/var/run/nginx.pid --lock-path=/var/run/nginx.lock --http-client-body-temp-path=/var/cache/nginx/client_temp --http-proxy-temp-path=/var/cache/nginx/proxy_temp --http-fastcgi-temp-path=/var/cache/nginx/fastcgi_temp --http-uwsgi-temp-path=/var/cache/nginx/uwsgi_temp --http-scgi-temp-path=/var/cache/nginx/scgi_temp --user=nginx --group=nginx --with-file-aio --with-threads --with-ipv6 --with-http_addition_module --with-http_auth_request_module --with-http_dav_module --with-http_flv_module --with-http_gunzip_module --with-http_gzip_static_module --with-http_mp4_module --with-http_random_index_module --with-http_realip_module --with-http_secure_link_module --with-http_slice_module --with-http_ssl_module --with-http_stub_status_module --with-http_sub_module --with-http_v2_module --with-mail --with-mail_ssl_module --with-stream --with-stream_ssl_module --with-cc-opt=&apos;-O2 -g -pipe -Wall -Wp,-D_FORTIFY_SOURCE=2 -fexceptions -fstack-protector --param=ssp-buffer-size=4 -m64 -mtune=generic&apos; 备份原nginx下载新版本的nginx和需要添加的模块并解压下载nginx 1.10.21$wget http://nginx.org/download/nginx-1.10.2.tar.gz 下载 nginx-upload-module1$wget https://codeload.github.com/vkholodkov/nginx-upload-module/tar.gz/2.2.0 下载 nginx-upload-progress-module1$wget https://github.com/masterzen/nginx-upload-progress-module/archive/v0.9.2.tar.gz 下载 ngx_cache_purge1$wget https://codeload.github.com/FRiCKLE/ngx_cache_purge/tar.gz/2.3 解压1234$ tar zxf nginx-1.10.2.tar.gz$ tar zxf nginx-upload-module-2.2.0.tar.gz$ tar zxf nginx-upload-progress-module.tar.gz$ tar zxf ngx_cache_purge-2.3.tar.gz 升级并添加新模块1./configure --prefix=/etc/nginx --sbin-path=/usr/sbin/nginx --modules-path=/usr/lib64/nginx/modules --conf-path=/etc/nginx/nginx.conf --error-log-path=/var/log/nginx/error.log --http-log-path=/var/log/nginx/access.log --pid-path=/var/run/nginx.pid --lock-path=/var/run/nginx.lock --http-client-body-temp-path=/var/cache/nginx/client_temp --http-proxy-temp-path=/var/cache/nginx/proxy_temp --http-fastcgi-temp-path=/var/cache/nginx/fastcgi_temp --http-uwsgi-temp-path=/var/cache/nginx/uwsgi_temp --http-scgi-temp-path=/var/cache/nginx/scgi_temp --user=nginx --group=nginx --with-file-aio --with-threads --with-ipv6 --with-http_addition_module --with-http_auth_request_module --with-http_dav_module --with-http_flv_module --with-http_gunzip_module --with-http_gzip_static_module --with-http_mp4_module --with-http_random_index_module --with-http_realip_module --with-http_secure_link_module --with-http_slice_module --with-http_ssl_module --with-http_stub_status_module --with-http_sub_module --with-http_v2_module --with-mail --with-mail_ssl_module --with-stream --with-stream_ssl_module --add-module=/root/nginxinstall/nginx-upload-module-2.0.12 --add-module=/root/nginxinstall/nginx-upload-progress-module-82b35fc --add-module=/root/nginxinstall/ngx_cache_purge-2.3 --with-cc-opt=&apos;-O2 -g -pipe -Wall -Wp,-D_FORTIFY_SOURCE=2 -fexceptions -fstack-protector --param=ssp-buffer-size=4 -m64 -mtune=generic&apos;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[osx 常用开发工具]]></title>
      <url>%2F2016%2F09%2F10%2Fosx-dev-tools%2F</url>
      <content type="text"><![CDATA[ZSHinstallsh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot; homebrewinstall/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; iterm2installbrew cask install iterm2 dev toolmysqlinstallbrew install mysql startmysql.server start redisinstallbrew install redis ==&gt; Downloading https://homebrew.bintray.com/bottles/redis-3.2.3.el_capitan.bottle.tar.gz curl: (7) Failed to connect to akamai.bintray.com port 443: Operation timed out Error: Failed to download resource &quot;redis&quot; Download failed: https://homebrew.bintray.com/bottles/redis-3.2.3.el_capitan.bottle.tar.gz Warning: Bottle installation failed: building from source. ==&gt; Using the sandbox ==&gt; Downloading http://download.redis.io/releases/redis-3.2.3.tar.gz ==&gt; Downloading from http://101.44.1.117/files/B22400000598F419/download.redis.io/releases/redis-3.2.3.tar.gz ######################################################################## 100.0% ==&gt; make install PREFIX=/usr/local/Cellar/redis/3.2.3 CC=clang ==&gt; Caveats To have launchd start redis now and restart at login: brew services start redis Or, if you don&apos;t want/need a background service you can just run: redis-server /usr/local/etc/redis.conf ==&gt; Summary 🍺 /usr/local/Cellar/redis/3.2.3: 10 files, 1.7M, built in 13 seconds startbrew services start redis JDKinstallbrew cask install java java -version java version &quot;1.8.0_102&quot; Java(TM) SE Runtime Environment (build 1.8.0_102-b14) Java HotSpot(TM) 64-Bit Server VM (build 25.102-b14, mixed mode) maveninstallbrew cask install maven mvn -v Apache Maven 3.3.9 (bb52d8502b132ec0a5a3f4c09453c07478323dc5; 2015-11-11T00:41:47+08:00) Maven home: /usr/local/Cellar/maven/3.3.9/libexec Java version: 1.8.0_102, vendor: Oracle Corporation Java home: /Library/Java/JavaVirtualMachines/jdk1.8.0_102.jdk/Contents/Home/jre Default locale: en_US, platform encoding: UTF-8 OS name: &quot;mac os x&quot;, version: &quot;10.11.6&quot;, arch: &quot;x86_64&quot;, family: &quot;mac&quot; gradleinstallbrew cask install gradle gradle -v ------------------------------------------------------------ Gradle 3.0 ------------------------------------------------------------ Build time: 2016-08-15 13:15:01 UTC Revision: ad76ba00f59ecb287bd3c037bd25fc3df13ca558 Groovy: 2.4.7 Ant: Apache Ant(TM) version 1.9.6 compiled on June 29 2015 JVM: 1.8.0_102 (Oracle Corporation 25.102-b14) OS: Mac OS X 10.11.6 x86_64 groovyinstallbrew cask install groovy caskcask 可以安装很多软件、例如jdk，maven， groovy， macDown， idea 等等一系列软件都可以通过cask安装]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[服务器小脚本尝试]]></title>
      <url>%2F2016%2F03%2F30%2Fserver-bash%2F</url>
      <content type="text"><![CDATA[###备份MySQL数据库 123#!/bin/bashmysqldump -uroot -proot cswebsite &gt; /root/cswebsite_`date +%Y%m%d%H%M%S`.sql ###备份tomcat 应用 12345678910111213141516#!/bin/bashecho &quot;shutdown tomcat..&quot;/root/tomcat8/bin/shutdown.shecho &quot;begin backup stillone...&quot;tar -zcvf /root/backup/stillone_`date +%Y%m%d%H%M%S`.tar.gz /root/tomcat8/webapps/ROOT --exclude=Files --exclude=uploadFilesecho &quot;&quot;echo &quot;&quot;echo &quot;&quot;echo -e &quot;\033[32;49;1m backup stillone done! have fun!! \033[39;49;0m&quot;echo &quot;&quot;echo &quot;&quot; 筛选nginx日志访问量IP排名top1000(http 状态码403 请求路径/v2/sms/send)awk &apos;{if($9==&quot;403&quot; &amp;&amp; $7==&quot;/v2/sms/send&quot;) print $1}&apos; /usr/local/tomcat/nginx-log/api.credan.com.log | sort | uniq -c | sort -nr -k1|head -n 1000]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[redis 整理（六）ZSet 类型]]></title>
      <url>%2F2015%2F03%2F04%2Fredis-datatype-zset%2F</url>
      <content type="text"><![CDATA[zset 类型简介zset全称为sorted-sets类型,和set数据类型有极为相似,都是字符串的集合,都不允许重复的成员出现在一个set中.两者的主要区别是zset的每一个成员都会有一个分数(score)与之关联.redis正是通过分数来为集合中的成员进行从小到大的排序.zset的成员是唯一的,但分数(score)却可以重复.在zset中添加、删除或更新一个成员都是非常快速的操作，其时间复杂度为集合中成员数量的对数. Sorted-Sets中的成员在集合中的位置是有序的. zset 操作1. zadd命令格式: zadd key score member [[score] [member] …] 描述：将一个或多个 member 元素及其 score 值加入到有序集 key 当中.如果某个 member 已经是有序集的成员，那么更新这个 member 的 score 值，并通过重新插入这个 member 元素，来保证该 member 在正确的位置上。score 值可以是整数值或双精度浮点数。如果 key 不存在，则创建一个空的有序集并执行 ZADD 操作。当 key 存在但不是有序集类型时，返回一个错误。 时间复杂度: O(M*log(N))， N 是有序集的基数， M 为成功添加的新成员的数量 返回值:被成功添加的新成员的数量，不包括那些被更新的、已经存在的成员。 添加一个元素 127.0.0.1:6379[1]&gt; zadd zset_list 11 test1 (integer) 1 添加多个元素 127.0.0.1:6379[1]&gt; zadd zset_list 1 test2 2 test3 (integer) 2 查看元素 127.0.0.1:6379[1]&gt; zrange zset_list 0 -1 1) &quot;test2&quot; 2) &quot;test3&quot; 3) &quot;test1&quot; 查看元素带score值 127.0.0.1:6379[1]&gt; zrange zset_list 0 -1 withscores 1) &quot;test2&quot; 2) &quot;1&quot; 3) &quot;test3&quot; 4) &quot;2&quot; 5) &quot;test1&quot; 6) &quot;11&quot; 添加已存在元素，且 score 值不变 操作不成功返回0 127.0.0.1:6379[1]&gt; zadd zset_list 11 test1 (integer) 0 127.0.0.1:6379[1]&gt; zrange zset_list 0 -1 withscores 1) &quot;test2&quot; 2) &quot;1&quot; 3) &quot;test3&quot; 4) &quot;2&quot; 5) &quot;test1&quot; 6) &quot;11&quot; 添加已存在元素，但是改变 score 值 127.0.0.1:6379[1]&gt; zrange zset_list 0 -1 withscores 1) &quot;test2&quot; 2) &quot;1&quot; 3) &quot;test3&quot; 4) &quot;2&quot; 5) &quot;test1&quot; 6) &quot;3&quot; zrem命令格式: ZREM key member [member …] 描述:移除有序集 key 中的一个或多个成员，不存在的成员将被忽略。当 key 存在但不是有序集类型时，返回一个错误。 时间复杂度:O(M*log(N))， N 为有序集的基数， M 为被成功移除的成员的数量。 返回值:被成功移除的成员的数量，不包括被忽略的成员。 移除单个元素 127.0.0.1:6379[1]&gt; zrange zset_list 0 -1 withscores 1) &quot;test2&quot; 2) &quot;1&quot; 3) &quot;test3&quot; 4) &quot;2&quot; 5) &quot;test1&quot; 6) &quot;3&quot; 127.0.0.1:6379[1]&gt; zrem zset_list test1 (integer) 1 127.0.0.1:6379[1]&gt; zrange zset_list 0 -1 withscores 1) &quot;test2&quot; 2) &quot;1&quot; 3) &quot;test3&quot; 4) &quot;2&quot; 移除多个 127.0.0.1:6379[1]&gt; zrange zset_list 0 -1 withscores 1) &quot;test2&quot; 2) &quot;1&quot; 3) &quot;test3&quot; 4) &quot;2&quot; 127.0.0.1:6379[1]&gt; zrem zset_list test2 test3 (integer) 2 127.0.0.1:6379[1]&gt; zrange zset_list 0 -1 withscores (empty list or set) 移除不存在元素 127.0.0.1:6379[1]&gt; zrange zset_list 0 -1 withscores (empty list or set) 127.0.0.1:6379[1]&gt; zrem zset_list test2 (integer) 0 127.0.0.1:6379[1]&gt; zrange zset_list 0 -1 withscores (empty list or set) zcard描述：返回zset集合的成员数 时间复杂度：O(1) 返回值：当 key 存在且是有序集(zset)类型时，返回集合内的成员数。不存在返回0。 127.0.0.1:6379[1]&gt; zcard zset_list (integer) 0 127.0.0.1:6379[1]&gt; zadd zset_list 0 test1 (integer) 1 127.0.0.1:6379[1]&gt; zcard zset_list (integer) 1 127.0.0.1:6379[1]&gt; zadd zset_list 1 test2 2 test3 (integer) 2 127.0.0.1:6379[1]&gt; zcard zset_list (integer) 3 zcount命令格式:ZCOUNT key min max 描述：返回有序集 key 中， score 值在 min 和 max 之间(默认包括 score 值等于 min 或 max )的成员的数量。 时间复杂度: O(log(N)+M)， N 为有序集的基数， M 为值在 min 和 max 之间的元素的数量。 返回值：score 值在 min 和 max 之间的成员的数量。 127.0.0.1:6379[1]&gt; zrange zset_list 0 -1 withscores 1) &quot;test1&quot; 2) &quot;0&quot; 3) &quot;test2&quot; 4) &quot;1&quot; 5) &quot;test3&quot; 6) &quot;2&quot; 127.0.0.1:6379[1]&gt; zcount zset_list 1 2 (integer) 2 127.0.0.1:6379[1]&gt; zcount zset_list 0 2 (integer) 3 127.0.0.1:6379[1]&gt; zcount zset_list 2 2 (integer) 1 zscore命令格式:ZSCORE key member 描述:返回有序集 key 中，成员 member 的 score 值。如果 member 元素不是有序集 key 的成员，或 key 不存在，返回 nil 。 时间复杂度:O(1) 127.0.0.1:6379[1]&gt; zrange zset_list 0 -1 withscores 1) &quot;test1&quot; 2) &quot;0&quot; 3) &quot;test2&quot; 4) &quot;1&quot; 5) &quot;test3&quot; 6) &quot;2&quot; 127.0.0.1:6379[1]&gt; zscore zset_list test2 &quot;1&quot; 127.0.0.1:6379[1]&gt; zscore zset_list test5 (nil) zincrby命令格式：ZINCRBY key increment member 描述：为有序集 key 的成员 member 的 score 值加上增量 increment 。 时间复杂度：O(log(N)) 返回值： 返回member 成员的新 score 值，以字符串形式表示。 127.0.0.1:6379[1]&gt; zscore zset_list test2 &quot;1&quot; 127.0.0.1:6379[1]&gt; zincrby zset_list 2 test2 &quot;3&quot; 127.0.0.1:6379[1]&gt; zincrby zset_list -2 test2 &quot;1&quot; zrange命令格式: ZRANGE key start stop [WITHSCORES] 描述：返回指定区间的成员。其中成员位置按 score 值递增(从小到大)来排序。 WITHSCORES选项是用来让成员和它的score值一并返回.(在前面我们已经用到过) 时间复杂度:O(log(N)+M)， N 为有序集的基数，而 M 为结果集的基数。 返回值：返回指定区间的成员列表. 127.0.0.1:6379[1]&gt; zrange zset_list 1 2 1) &quot;test2&quot; 2) &quot;test3&quot; 127.0.0.1:6379[1]&gt; zrange zset_list 0 2 1) &quot;test1&quot; 2) &quot;test2&quot; 3) &quot;test3&quot; 127.0.0.1:6379[1]&gt; zrange zset_list 0 -1 1) &quot;test1&quot; 2) &quot;test2&quot; 3) &quot;test3&quot; 127.0.0.1:6379[1]&gt; zrange zset_list 0 -1 withscores 1) &quot;test1&quot; 2) &quot;0&quot; 3) &quot;test2&quot; 4) &quot;1&quot; 5) &quot;test3&quot; 6) &quot;2&quot; 当给定区间不存在于有序集时的情况 127.0.0.1:6379[1]&gt; zrange zset_list 10 20 (empty list or set) zrevrange命令格式：ZREVRANGE key start stop [WITHSCORES] 描述：和zrange一样使用，唯一不同是其成员位置按 score 值递减(从大到小)来排列。 127.0.0.1:6379[1]&gt; zrange zset_list 0 -1 withscores 1) &quot;test1&quot; 2) &quot;0&quot; 3) &quot;test2&quot; 4) &quot;1&quot; 5) &quot;test3&quot; 6) &quot;2&quot; 127.0.0.1:6379[1]&gt; zrevrange zset_list 0 -1 withscores 1) &quot;test3&quot; 2) &quot;2&quot; 3) &quot;test2&quot; 4) &quot;1&quot; 5) &quot;test1&quot; 6) &quot;0&quot; zrangebyscore命令格式：ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count] 描述：返回有序集key中所有score值介于min与max之间(包括等于)的成员.成员按score值递增(从小到大)排列 。min 和 max 可以是 -inf 和 +inf可选limit参数指定返回结果的数量及区间。 时间复杂度：O(log(N)+M)， N 为有序集的基数， M 为被结果集的基数。 返回值：指定区间内，带有 score 值(可选)的有序集成员的列表。 127.0.0.1:6379[1]&gt; zrangebyscore zset_list -inf +inf 1) &quot;test1&quot; 2) &quot;test2&quot; 3) &quot;test3&quot; 127.0.0.1:6379[1]&gt; zrangebyscore zset_list -inf +inf withscores 1) &quot;test1&quot; 2) &quot;0&quot; 3) &quot;test2&quot; 4) &quot;1&quot; 5) &quot;test3&quot; 6) &quot;2&quot; 127.0.0.1:6379[1]&gt; zrangebyscore zset_list 1 +inf withscores 1) &quot;test2&quot; 2) &quot;1&quot; 3) &quot;test3&quot; 4) &quot;2&quot; 显示大于2 小于等于10的成员 127.0.0.1:6379[1]&gt; zrangebyscore zset_list -inf +inf withscores 1) &quot;test1&quot; 2) &quot;0&quot; 3) &quot;test2&quot; 4) &quot;1&quot; 5) &quot;test3&quot; 6) &quot;2&quot; 127.0.0.1:6379[1]&gt; zrangebyscore zset_list (1 10 1) &quot;test3 显示条件 1 &lt; score &lt; 10 的成员 127.0.0.1:6379[1]&gt; zrangebyscore zset_list (1 (10 1) &quot;test3&quot; zrevrangebyscore命令格式: zrevrangebyscore key max min [WITHSCORES] [LIMIT offset count] 描述：和zrangebyscore一样，唯一不同的是成员按 score 值递减(从大到小)的次序排列。 127.0.0.1:6379[1]&gt; zrangebyscore zset_list -inf +inf withscores 1) &quot;test1&quot; 2) &quot;0&quot; 3) &quot;test2&quot; 4) &quot;1&quot; 5) &quot;test3&quot; 6) &quot;2&quot; 127.0.0.1:6379[1]&gt; zrevrangebyscore zset_list +inf -inf withscores 1) &quot;test3&quot; 2) &quot;2&quot; 3) &quot;test2&quot; 4) &quot;1&quot; 5) &quot;test1&quot; 6) &quot;0&quot; zrank命令格式： zrank key member 描述：返回有序集key中成员member的排名。成员按 score 值递增(从小到大)顺序排列。排名以0开始，也就是说score 值最小的为0. 时间复杂度:O(log(N)) 返回值：返回成员排名，member不存在返回nil. 127.0.0.1:6379[1]&gt; zrank zset_list test1 (integer) 0 zrevrank命令格式： zrevrank key member 描述：返回有序集key中成员member的排名。成员按 score 值递增(从大到小)顺序排列。排名以0开始，也就是说score 值最大的为0. 时间复杂度:O(log(N)) 返回值：返回成员排名，member不存在返回nil. 127.0.0.1:6379[1]&gt; zrevrank zset_list test3 (integer) 0 zremrangebyrank命令格式: ZREMRANGEBYRANK key start stop 描述：移除有序集 key 中，指定排名(rank)区间内的所有成员。区间分别以下标参数 start 和 stop 指出，包含 start 和 stop 在内。下标参数 start 和 stop 都以 0 为底，也就是说，以 0 表示有序集第一个成员，以 1 表示有序集第二个成员，以此类推。你也可以使用负数下标，以 -1 表示最后一个成员， -2 表示倒数第二个成员，以此类推。 时间复杂度:O(log(N)+M)， N 为有序集的基数，而 M 为被移除成员的数量。 返回值:被移除成员的数量。 127.0.0.1:6379[1]&gt; zrange zset_list 0 -1 withscores 1) &quot;test1&quot; 2) &quot;0&quot; 3) &quot;test2&quot; 4) &quot;1&quot; 5) &quot;test3&quot; 6) &quot;2&quot; 127.0.0.1:6379[1]&gt; zremrangebyrank zset_list 1 2 (integer) 2 127.0.0.1:6379[1]&gt; zrange zset_list 0 -1 withscores 1) &quot;test1&quot; 2) &quot;0&quot; zremrangebyscore命令格式：zremrangebyscore key min max 描述：移除score值介于min和max之间（等于）的成员 时间复杂度:O(log(N)+M)， N 为有序集的基数，而 M 为被移除成员的数量。 返回值:被移除成员的数量。 移除所有score在 100 到 110 内的数据 127.0.0.1:6379[1]&gt; zrange zset_list 0 -1 withscores 1) &quot;test1&quot; 2) &quot;0&quot; 3) &quot;test11&quot; 4) &quot;100&quot; 5) &quot;test22&quot; 6) &quot;101&quot; 127.0.0.1:6379[1]&gt; zremrangebyscore zset_list 100 110 (integer) 2 127.0.0.1:6379[1]&gt; zrange zset_list 0 -1 withscores 1) &quot;test1&quot; 2) &quot;0&quot; zunionstore命令格式：ZUNIONSTORE destination numkeys key [key …] [WEIGHTS weight [weight …]] [AGGREGATE SUM|MIN|MAX] 描述：计算给定的一个或多个有序集的并集，其中给定 key 的数量必须以 numkeys 参数指定，并将该并集(结果集)储存到 destination 。默认情况下，结果集中某个成员的 score 值是所有给定集下该成员 score 值之 和 。 127.0.0.1:6379[1]&gt; zadd zset1 1 test1 2 test2 (integer) 2 127.0.0.1:6379[1]&gt; zrange zset_list 0 -1 withscores 1) &quot;test1&quot; 2) &quot;0&quot; 127.0.0.1:6379[1]&gt; zadd zset_list 1 test2 (integer) 1 127.0.0.1:6379[1]&gt; zunionstore dis_set 2 zset_list zset1 (integer) 2 127.0.0.1:6379[1]&gt; zrange dis_set 0 -1 withscores 1) &quot;test1&quot; 2) &quot;1&quot; 3) &quot;test2&quot; 4) &quot;3&quot; 127.0.0.1:6379[1]&gt; zrange zset1 0 -1 withscores 1) &quot;test1&quot; 2) &quot;1&quot; 3) &quot;test2&quot; 4) &quot;2&quot; 127.0.0.1:6379[1]&gt; zrange zset_list 0 -1 withscores 1) &quot;test1&quot; 2) &quot;0&quot; 3) &quot;test2&quot; 4) &quot;1&quot; 127.0.0.1:6379[1]&gt; zadd zset_list 3 test3 (integer) 1 127.0.0.1:6379[1]&gt; zunionstore dis_set1 2 zset_list zset1 (integer) 3 127.0.0.1:6379[1]&gt; zrange dis_set1 0 -1 withscores 1) &quot;test1&quot; 2) &quot;1&quot; 3) &quot;test2&quot; 4) &quot;3&quot; 5) &quot;test3&quot; 6) &quot;3&quot; zinterstore命令格式：ZINTERSTORE destination numkeys key [key …] [WEIGHTS weight [weight …]] [AGGREGATE SUM|MIN|MAX] 描述：计算给定的一个或多个有序集的交集。其中给定 key 的数量必须以 numkeys 参数指定，并将该交集(结果集)储存到 destination 。默认情况下，结果集中某个成员的 score 值是所有给定集下该成员 score 值之 和 。 时间复杂度：O(NK)+O(Mlog(M))， N 为给定 key 中基数最小的有序集， K 为给定有序集的数量， M 为结果集的基数。 返回值：保存到 destination 的结果集成员数。 127.0.0.1:6379[1]&gt; zrange zset1 0 -1 withscores 1) &quot;test1&quot; 2) &quot;1&quot; 3) &quot;test2&quot; 4) &quot;2&quot; 127.0.0.1:6379[1]&gt; zrange zset_list 0 -1 withscores 1) &quot;test1&quot; 2) &quot;0&quot; 3) &quot;test2&quot; 4) &quot;1&quot; 5) &quot;test3&quot; 6) &quot;3&quot; 127.0.0.1:6379[1]&gt; zinterstore dis_set2 2 zset1 zset_list (integer) 2 127.0.0.1:6379[1]&gt; zrange dis_set2 0 -1 withscores 1) &quot;test1&quot; 2) &quot;1&quot; 3) &quot;test2&quot; 4) &quot;3&quot;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[redis 整理（七）key（键）的相关操作]]></title>
      <url>%2F2015%2F03%2F04%2Fredis-key-operation%2F</url>
      <content type="text"><![CDATA[del时间复杂度: String类型其时间复杂度为O(1)。 其余O(N) N表删除key数量. 描述：删除 返回值: 实际被删除的KEY数量 操作命令如下: redis 127.0.0.1:6379&gt; del my_set_diff my_set (integer) 2 keys命令格式: keys pattern 描述: 获取所有匹配PATTERN参数的keys. 时间复杂度: O(N) 表KEY的数量. 返回值:匹配模式的键列表。 操作命令如下: redis 127.0.0.1:6379&gt; keys my* 1) “my_set_2″ 2) “myset2″ 3) “myset5″ 4) “myset” exists描述: 判断指定键是否存在。1存在,0不存在. 时间复杂度:O(1) 操作命令如下: redis 127.0.0.1:6379&gt; exists myset (integer) 1 redis 127.0.0.1:6379&gt; exists myset9 (integer) 0 move命令格式: move key db 时间复杂度:O(1) 描述: 将当前数据库中指定的键Key移动到参数中指定的数据库中。如果该Key在目标数据库中已经存在，或者在当前数据库中并不存在，该命令将不做任何操作并返回0。redis中默认有16个数据库，默认从0开始到15。 返回值:成功1 否则0 rename命令格式: rename key newkey 时间复杂度:O(1) 描述: 重命名key,key不存在将报错,如果newKey存在则直接覆盖 renamenx命令格式: renamenx key newkey 时间复杂度:O(1) 描述:当newkey不存在时才重命名. 返回值: 成功返回1,如里newkey已经存在,返回0. persist命令格式:persist key 时间复杂度: O(1) 描述:移除给定key的生存时间。 返回值:1表示Key的过期时间被移出，0表示该Key不存在或没有过期时间。 expire命令格式:EXPIRE key seconds 时间复杂度: O(1) 描述:为给定key设置生存时间。当key过期时，它会被自动删除 返回值:设置成功返回1。当key不存在或者不能为key设置生存时间，返回0。 expireat命令格式:expireat key timetamp 时间复杂度: O(1) 描述:EXPIREAT的作用和EXPIRE一样，都用于为key设置生存时间。不同在于EXPIREAT命令接受的时间参数是UNIX时间戳(unix timestamp)。 返回值:设置成功返回1。当key不存在或者不能为key设置生存时间，返回0。 ttl命令格式:ttl key 时间复杂度: O(1) 描述:返回给定key的剩余生存时间(time to live)(以秒为单位)。 返回值:key的剩余生存时间(以秒为单位)。当key不存在或没有设置生存时间时，返回-1 。 randomkey时间复杂度: O(1) 描述:随机的返回一个Key。 返回值:返回的随机键，如果该数据库是空的则返回nil。 type命令格式:type key 时间复杂度: O(1) 描述:获取key的类型 返回值: 返回的字符串为string、list、set、hash和zset，如果key不存在返回none。 dump命令格式:dump key 可用版本:reidis&gt;=2.6.0 时间复杂度: O(1) 描述:序列化给定key,并返回被序列化的值,使用 RESTORE 命令可以将这个值反序列化为 Redis 键。 返回值: 如key不存在返回nli,否则返回被序列化的值.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java 重载与重写的区别]]></title>
      <url>%2F2014%2F08%2F15%2Fjava-overloading-Overriding%2F</url>
      <content type="text"><![CDATA[重载(Overloading)（1） 方法重载是让类以统一的方式处理不同类型数据的一种手段。多个同名函数同时存在，具有不同的参数个数/类型。 重载Overloading是一个类中多态性的一种表现。 （2）Java的方法重载，就是在类中可以创建多个方法，它们具有相同的名字，但具有不同的参数和不同的定义。 调用方法时通过传递给它们的不同参数个数和参数类型来决定具体使用哪个方法, 这就是多态性。 （3） 重载的时候，方法名要一样，但是参数类型和个数不一样，返回值类型可以相同也可以不相同。无法以返回型别作为重载函数的区分标准。 下面是重载的例子：package c04.answer;//这是包名//这是这个程序的第一种编程方法，在main方法中先创建一个Dog类实例，然后在Dog类的构造方法中利用this关键字调用不同的bark方法。 不同的重载方法bark是根据其参数类型的不同而区分的。 //注意：除构造器以外，编译器禁止在其他任何地方中调用构造器。 package c04.answer; public class Dog { Dog(){ this.bark(); } //bark()方法是重载方法 void bark(){ System.out.println(&quot;no barking!&quot;); this.bark(&quot;female&quot;, 3.4); } //注意：重载的方法的返回值都是一样的， void bark(String m,double l) { System.out.println(&quot;a barking dog!&quot;); this.bark(5, &quot;China&quot;); } //不能以返回值区分重载方法，而只能以“参数类型”和“类名”来区分 void bark(int a,String n) { System.out.println(&quot;a howling dog&quot;); } public static void main(String[] args) { Dog dog = new Dog(); //dog.bark(); [Page] //dog.bark(&quot;male&quot;, &quot;yellow&quot;); //dog.bark(5, &quot;China&quot;); } } 重写（Overriding）（1） 父类与子类之间的多态性，对父类的函数进行重新定义。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。在Java中，子类可继承父类中的方法，而不需要重新编写相同的方法。 但有时子类并不想原封不动地继承父类的方法，而是想作一定的修改，这就需要采用方法的重写。 方法重写又称方法覆盖。 （2）若子类中的方法与父类中的某一方法具有相同的方法名、返回类型和参数表，则新方法将覆盖原有的方法。 如需父类中原有的方法，可使用super关键字，该关键字引用了当前类的父类。 （3）子类函数的访问修饰权限不能少于父类的；下面是重写的例子： 概念：即调用对象方法的机制。 动态绑定的内幕： 1、编译器检查对象声明的类型和方法名，从而获取所有候选方法。试着把上例Base类的test注释掉，这时再编译就无法通过。 2、重载决策：编译器检查方法调用的参数类型，从上述候选方法选出唯一的那一个（其间会有隐含类型转化）。 如果编译器找到多于一个或者没找到，此时编译器就会报错。试着把上例Base类的test(byte b)注释掉，这时运行结果是1 1。 3、若方法类型为priavte static final ，java采用静态编译，编译器会准确知道该调用哪个方法。 4、当程序运行并且使用动态绑定来调用一个方法时，那么虚拟机必须调用对象的实际类型相匹配的方法版本。 在例子中，b所指向的实际类型是TestOverriding，所以b.test(0)调用子类的test。 但是，子类并没有重写test(byte b)，所以b.test((byte)0)调用的是父类的test(byte b)。 如果把父类的(byte b)注释掉，则通过第二步隐含类型转化为int,最终调用的是子类的test(int i)。 学习总结： 多态性是面向对象编程的一种特性，和方法无关，简单说，就是同样的一个方法能够根据输入数据的不同，做出不同的处理，即方法的重载——有不同的参数列表（静态多态性） 而当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法， 即在子类中重写该方法——相同参数，不同实现（动态多态性） OOP三大特性：继承，多态，封装。 public class Base { void test(int i) { System.out.print(i); } void test(byte b){ System.out.print(b); } } public class TestOverriding extends Base { void test(int i) { i++; System.out.println(i); } public static void main(String[]agrs) { Base b=new TestOverriding(); b.test(0) b.test((byte)0) } } 这时的输出结果是1 0，这是运行时动态绑定的结果。 重写的主要优点是能够定义某个子类特有的特征： public class Father{ public void speak(){ System.out.println(Father); } } public class SonextendsFather{ public void speak(){ System.out.println(&quot;son&quot;); } } 这也叫做多态性，重写方法只能存在于具有继承关系中，重写方法只能重写父类非私有的方法。 当上例中Father类speak()方法被private时，Son类不能重写出Father类speak()方法，此时Son类speak()方法相当与在Son类中定义的一个speak()方法。 Father类speak()方法一但被final时，无论该方法被public,protected及默认所修饰时，Son类根本不能重写Father类speak()方法， 试图编译代码时，编译器会报错。例： public class Father{ final public void speak(){ System.out.println(&quot;Father&quot;); } } public class SonextendsFather{ public void speak(){ System.out.println(&quot;son&quot;); } }//编译器会报错； Father类speak()方法被默认修饰时，只能在同一包中，被其子类被重写，如果不在同一包则不能重写。 Father类speak()方法被protoeted时，不仅在同一包中，被其子类被重写，还可以不同包的子类重写。 重写方法的规则： 1、参数列表必须完全与被重写的方法相同，否则不能称其为重写而是重载。 2、返回的类型必须一直与被重写的方法的返回类型相同，否则不能称其为重写而是重载。 3、访问修饰符的限制一定要大于被重写方法的访问修饰符（public&gt;protected&gt;default&gt;private） 4、重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常。例如： 父类的一个方法申明了一个检查异常IOException，在重写这个方法是就不能抛出Exception,只能抛出IOException的子类异常，可以抛出非检查异常。 而重载的规则： 1、必须具有不同的参数列表； 2、可以有不责骂的返回类型，只要参数列表不同就可以了； 3、可以有不同的访问修饰符； 4、可以抛出不同的异常； 重写与重载的区别在于： 重写多态性起作用，对调用被重载过的方法可以大大减少代码的输入量，同一个方法名只要往里面传递不同的参数就可以拥有不同的功能或返回值。 用好重写和重载可以设计一个结构清晰而简洁的类，可以说重写和重载在编写代码过程中的作用非同一般. （来源：博客园）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java中关于Map的九大问题]]></title>
      <url>%2F2014%2F08%2F14%2Fjava-map-9-problems%2F</url>
      <content type="text"><![CDATA[通常来说，Map是一个由键值对组成的数据结构，且在集合中每个键是唯一的。下面就以K和V来代表键和值，来说明一下java中关于Map的九大问题。 1、将Map转换为List类型在java中Map接口提供了三种集合获取方式：Key set,，value set， and key-value set.。它们都可以通过构造方法或者addAll()方法来转换为List类型。下面代码就说明了如何从Map中构造ArrayList： // key list List keyList = new ArrayList(map.keySet()); // value list List valueList = new ArrayList(map.valueSet()); // key-value list List entryList = new ArrayList(map.entrySet()); 2、通过Entry 遍历Mapjava中这种以键值对存在的方式被称为Map.Entry。Map.entrySet()返回的是一个key-value 集合，这是一种非常高效的遍历方式。 for(Entry entry: map.entrySet()) { // get key K key = entry.getKey(); // get value V value = entry.getValue(); } Iterator 我们也经常用到，尤其是在JDK1.5以前 Iterator itr = map.entrySet().iterator(); while(itr.hasNext()) { Entry entry = itr.next(); // get key K key = entry.getKey(); // get value V value = entry.getValue(); } 3、通过Key来对Map排序排序需要对Map的ke进行频繁的操作，一种方式就是通过比较器(comparator )来实现： List list = new ArrayList(map.entrySet()); Collections.sort(list, new Comparator() { @Override public int compare(Entry e1, Entry e2) { return e1.getKey().compareTo(e2.getKey()); } }); 另外一种方法就是通过SortedMap，但必须要实现Comparable接口。 SortedMap sortedMap = new TreeMap(new Comparator() { @Override public int compare(K k1, K k2) { return k1.compareTo(k2); } }); sortedMap.putAll(map); 4、对value对Map进行排序这与上一点有些类似，代码如下： List list = new ArrayList(map.entrySet()); Collections.sort(list, new Comparator() { @Override public int compare(Entry e1, Entry e2) { return e1.getValue().compareTo(e2.getValue()); } }); 5、初始化一个static 的常量Map当你希望创建一个全局静态Map的时候，我们有以下两种方式，而且是线程安全的。而在Test1中，我们虽然声明了map是静态的，但是在初始化时，我们依然可以改变它的值，就像Test1.map.put(3,”three”);在Test2中，我们通过一个内部类，将其设置为不可修改，那么当我们运行Test2.map.put(3,”three”)的时候，它就会抛出一个UnsupportedOperationException 异常来禁止你修改。 public class Test1 { private static final Map map; static { map = new HashMap(); map.put(1, “one”); map.put(2, “two”); } } public class Test2 { private static final Map map; static { Map aMap = new HashMap(); aMap.put(1, “one”); aMap.put(2, “two”); map = Collections.unmodifiableMap(aMap); } } 6、HashMap, TreeMap, and Hashtable之间的不同在Map接口中，共有三种实现：HashMap，TreeMap，Hashtable。 它们之间各有不同，详细内容请参考《 HashMap vs. TreeMap vs. Hashtable vs. LinkedHashMap》一文。 6、Map中的反向查询我们在Map添加一个键值对后，意味着这在Map中键和值是一一对应的，一个键就是对应一个值。但是有时候我们需要反向查询，比如通过某一个值来查找它的键，这种数据结构被称为bidirectional map，遗憾的是JDK并没有对其支持。 Apache和Guava 共同提供了这种bidirectional map实现，它在实现中它规定了键和值都是必须是1:1的关系。 7、对Map的复制java中提供了很多方法都可以实现对一个Map的复制，但是那些方法不见得会时时同步。简单说，就是一个Map发生的变化，而复制的那个依然保持原样。下面是一个比较高效的实现方法： Map copiedMap = Collections.synchronizedMap(map); 当然还有另外一个方法，那就是克隆。但是我们的java鼻祖Josh Bloch却不推荐这种方式，他曾经在一次访谈中说过关于Map克隆的问题：在很多类中都提供了克隆的方法，因为人们确实需要。但是克隆非常有局限性，而且在很多时候造成了不必要的影响。（原文《Copy constructor versus cloning》） 8、创建一个空的Map如果这个map被置为不可用，可以通过以下实现 map = Collections.emptyMap(); 相反，我们会用到的时候，就可以直接 map = new HashMap(); 文章源自：IT学习者]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[redis 整理（五）set 类型]]></title>
      <url>%2F2014%2F08%2F10%2Fredis-datatype-set%2F</url>
      <content type="text"><![CDATA[set 类型简介在Redis中，set是集合，和我们数学中的集合概念相似，对集合的操作有添加删除元素，有对多个几个求交并差等操作，操作中key理解为集合的名字。Redis的set是string类型的无序集合。set元素最大可以包含(2的32次方)个元素。set的十通过hash table实现的，所以添加、删除和查找的复杂度都是0（1）。hash table会随着添加或者删除自动的调整大小。需要注意的是调整hash table大小时候需要同步（获取写锁）会阻塞其他读写操作，可能不久后就会改用跳表来实现。关于set集合类型除了基本的添加删除操作，其他有用的操作还包括集合的取并集（union），交集（intersection），差集（difference）。通过这些操作可以很容易的实现sns中的好友推荐和blog的tag功能。 set 操作1. sadd向名称为key的set中添加元素 redis 127.0.0.1:6379&gt; sadd myset &quot;hello&quot; (integer) 1 redis 127.0.0.1:6379&gt; sadd myset &quot;world&quot; (integer) 1 redis 127.0.0.1:6379&gt; sadd myset &quot;world&quot; (integer) 0 redis 127.0.0.1:6379&gt; smembers myset 1) &quot;world&quot; 2) &quot;hello&quot; redis 127.0.0.1:6379&gt; 本例中，我们向myset中添加了三个元素，但由于第三个元素跟第二个元素十相同的，所以第三个元素没有添加成功，最后我们用smembers来查看myset中的所有元素。 2. srem删除名称为key的set中的元素member redis 127.0.0.1:6379&gt; sadd myset2 &quot;one&quot; (integer) 1 redis 127.0.0.1:6379&gt; sadd myset2 &quot;two&quot; (integer) 1 redis 127.0.0.1:6379&gt; sadd myset2 &quot;three&quot; (integer) 1 redis 127.0.0.1:6379&gt; srem myset2 &quot;one&quot; (integer) 1 redis 127.0.0.1:6379&gt; srem myset2 &quot;four&quot; (integer) 0 redis 127.0.0.1:6379&gt; smembers myset2 1) &quot;three&quot; 2) &quot;two&quot; redis 127.0.0.1:6379&gt; 本例中，我们向myset2中添加了三个元素后，再调用srem来删除one和four，但由于元素中没有four，所以，词条srem命令执行失败。 3. spop随即返回并删除名称为key的set中一个元素 redis 127.0.0.1:6379&gt; sadd myset3 &quot;one&quot; (integer) 1 redis 127.0.0.1:6379&gt; sadd myset3 &quot;two&quot; (integer) 1 redis 127.0.0.1:6379&gt; sadd myset3 &quot;three&quot; (integer) 1 redis 127.0.0.1:6379&gt; spop myset3 &quot;three&quot; redis 127.0.0.1:6379&gt; smembers myset3 1) &quot;two&quot; 2) &quot;one&quot; redis 127.0.0.1:6379&gt; 本例中，我们向myset3中添加三个元素后，在调用spop来随即删除一个元素，可以看到three元素被删除了。 4. sdiff返回所有给定key与第一个key的差集 redis 127.0.0.1:6379&gt; smembers myset2 1) &quot;three&quot; 2) &quot;two&quot; redis 127.0.0.1:6379&gt; smembers myset3 1) &quot;two&quot; 2) &quot;one&quot; redis 127.0.0.1:6379&gt; sdiff myset2 myset3 1) &quot;three&quot; redis 127.0.0.1:6379&gt; 本例中，我们可以看到myset2中的元素与myset3中不同的只是three，所以只有three被查询出来，而不是three和one，因为one是myset3的元素。我们也可以将myset2和myset3换个顺序来看一下结果： redis 127.0.0.1:6379&gt; sdiff myset3 myset2 1) &quot;one&quot; redis 127.0.0.1:6379&gt; 这个结果中只显示了，myset3中的元素与myset2中的不同的元素。 5. sdiffstore返回所有给定key与第一个key的差集，并将结果存为另一个key redis 127.0.0.1:6379&gt; smembers myset2 1) &quot;three&quot; 2) &quot;two&quot; redis 127.0.0.1:6379&gt; smembers myset3 1) &quot;two&quot; 2) &quot;one&quot; redis 127.0.0.1:6379&gt; sdiffstore myset4 myset2 myset3 (integer) 1 redis 127.0.0.1:6379&gt; smembers myset4 1) &quot;three&quot; redis 127.0.0.1:6379&gt; 6. sinter返回所有给定key的交集 redis 127.0.0.1:6379&gt; smembers myset2 1) &quot;three&quot; 2) &quot;two&quot; redis 127.0.0.1:6379&gt; smembers myset3 1) &quot;two&quot; 2) &quot;one&quot; redis 127.0.0.1:6379&gt; sinter myset2 myset3 1) &quot;two&quot; redis 127.0.0.1:6379&gt; 通过本例的结果可以看出，myset2和myset3的交集two被查出来了 7. sinterstore返回所有给定key的交集，并将结果存为另一个key redis 127.0.0.1:6379&gt; smembers myset2 1) &quot;three&quot; 2) &quot;two&quot; redis 127.0.0.1:6379&gt; smembers myset3 1) &quot;two&quot; 2) &quot;one&quot; redis 127.0.0.1:6379&gt; sinterstore myset5 myset2 myset3 (integer) 1 redis 127.0.0.1:6379&gt;smembers myset5 1) &quot;two&quot; redis 127.0.0.1:6379&gt; 通过本例的结果可以看出，myset2和myset3的交集被保存到myset5中了。 8. sunion返回所有给定key的并集 redis 127.0.0.1:6379&gt; smembers myset2 1) &quot;three&quot; 2) &quot;two&quot; redis 127.0.0.1:6379&gt; smembers myset3 1) &quot;two&quot; 2) &quot;one&quot; redis 127.0.0.1:6379&gt; sunion myset2 myset3 1) &quot;three&quot; 2) &quot;one&quot; 3) &quot;two&quot; redis 127.0.0.1:6379&gt; 通过本例的结果可以看出，myset2和myset3的并集被查出来了 9. sunionstore返回所有给定key的并集，并将结果存为另一个key redis 127.0.0.1:6379&gt; smembers myset2 1) &quot;three&quot; 2) &quot;two&quot; redis 127.0.0.1:6379&gt; smembers myset3 1) &quot;two&quot; 2) &quot;one&quot; redis 127.0.0.1:6379&gt; sunionstore myset6 myset2 myset3 (integer) 3 redis 127.0.0.1:6379&gt;smembers myset6 1) &quot;three&quot; 2) &quot;one&quot; 3) &quot;two&quot; redis 127.0.0.1:6379&gt; 通过本例的结果可以看出，myset2和myset3的并集被保存到myset6中了 10. smove从第一个key对应的set中一处member并添加到第二个对应set中 redis 127.0.0.1:6379&gt; smembers myset2 1) &quot;three&quot; 2) &quot;two&quot; redis 127.0.0.1:6379&gt; smembers myset3 1) &quot;two&quot; 2) &quot;one&quot; redis 127.0.0.1:6379&gt; smove myset2 myset7 three (integer) 1 redis 127.0.0.1:6379&gt;smembers myset7 1) &quot;three&quot; redis 127.0.0.1:6379&gt; 通过本例可以看到，myset2的three被移到myset7中了 11. scard返回名称为key的set的元素个数 redis 127.0.0.1:6379&gt; scard myset2 (integer) 1 redis 127.0.0.1:6379&gt; 通过本例可以看到，myset2的成员数量为1 12. sismember测试member是否是名称为key的set的元素 redis 127.0.0.1:6379&gt; smembers myset2 1) &quot;two&quot; redis 127.0.0.1:6379&gt; sismembers myset2 two (integer) 1 redis 127.0.0.1:6379&gt;sismember myset2 one (integer) 0 redis 127.0.0.1:6379&gt; 通过本例可以看到，two是myset2的成员，而one不是。 13. srandmember随机返回名称为key的set的一个元素，但是不删除元素 redis 127.0.0.1:6379&gt; smembers myset3 1) &quot;two&quot; 2) &quot;one&quot; redis 127.0.0.1:6379&gt; srandmember myset3 &quot;two&quot; redis 127.0.0.1:6379&gt;srandmember myset3 &quot;one&quot; redis 127.0.0.1:6379&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[redis 整理（四）List 类型]]></title>
      <url>%2F2014%2F08%2F09%2Fredis-datatype-list%2F</url>
      <content type="text"><![CDATA[list 类型简介List是一个链表结构，主要功能是push、pop、获取一个范围的所有值等等，操作中key理解为链表的名字。Redis的list类型其实就是一个每个子元素都是string类型的双向链表。我们可以通过push、pop操作从链表的头部或者尾部添加删除元素，这样list既可以作为栈，又可以作为队列。 list 操作1. lpush在key对应list的头部添加字符串元素 redis 127.0.0.1:6379&gt; lpush mylist &quot;world&quot; (integer) 1 redis 127.0.0.1:6379&gt; lpush mylist &quot;hello&quot; (integer) 2 redis 127.0.0.1:6379&gt; lrange mylist 0 -1 1) &quot;hello&quot; 2) &quot;world&quot; 2. rpush在key对应list的尾部添加字符串元素 redis 127.0.0.1:6379&gt; rpush mylist2 &quot;world&quot; (integer) 1 redis 127.0.0.1:6379&gt; rpush mylist2 &quot;hello&quot; (integer) 2 redis 127.0.0.1:6379&gt; lrange mylist2 0 -1 1) &quot;hello&quot; 2) &quot;world&quot; 3. linsert在key对应list的特定位置前或后添加字符串 redis 127.0.0.1:6379&gt; rpush mylist3 &quot;world&quot; (integer) 1 redis 127.0.0.1:6379&gt; linsert mylist3 before &quot;world&quot; &quot;hello&quot; (integer) 2 redis 127.0.0.1:6379&gt; lrange mylist3 0 -1 1) &quot;hello&quot; 2) &quot;world&quot; 4. lset设置list中指定下标的元素值 redis 127.0.0.1:6379&gt; rpush mylist4 &quot;hello&quot; (integer) 1 redis 127.0.0.1:6379&gt; lset mylist4 0 &quot;world&quot; OK redis 127.0.0.1:6379&gt; lrange mylist4 0 -1 1) &quot;world&quot; 5. lrem从key对应list中删除n个和value相同的元素。（n&lt;0从尾删除，n=0全部删除） redis 127.0.0.1:6379&gt; rpush mylist5 &quot;hello&quot; (integer) 1 redis 127.0.0.1:6379&gt; rpush mylist5 &quot;hello&quot; (integer) 1 redis 127.0.0.1:6379&gt; lrem mylist5 1 &quot;hello&quot; (integer) 1 6. ltrim保留指定key的值范围内的数据 redis 127.0.0.1:6379&gt; rpush mylist8 &quot;one&quot; (integer) 1 redis 127.0.0.1:6379&gt; rpush mylist8 &quot;two&quot; (integer) 2 redis 127.0.0.1:6379&gt; ltrim mylist8 1 -1 (integer) 1 redis 127.0.0.1:6379&gt; lrange mylist5 1 &quot;hello&quot; (integer) 1 6. lpop从list的头部删除元素，并返回删除元素 redis 127.0.0.1:6379&gt; lrange mylist 0 -1 1) &quot;hello&quot; 2) &quot;world&quot; redis 127.0.0.1:6379&gt; lpop mylist &quot;hello&quot; redis 127.0.0.1:6379&gt; lrange mylist 0 -1 &quot;world&quot; redis 127.0.0.1:6379&gt; 7. rpop从list的尾部删除元素，并返回删除元素 redis 127.0.0.1:6379&gt; lrange mylist2 0 -1 1) &quot;hello&quot; 2) &quot;world&quot; redis 127.0.0.1:6379&gt; rpop mylist2 &quot;world&quot; redis 127.0.0.1:6379&gt; lrange mylist2 0 -1 1) &quot;hello&quot; redis 127.0.0.1:6379&gt; 8. rpoplpush从第一个list的尾部移除元素并添加到第二个list的头部 redis 127.0.0.1:6379&gt; lrange mylist2 0 -1 1) &quot;hello&quot; 2) &quot;world&quot; redis 127.0.0.1:6379&gt; rpop mylist2 &quot;world&quot; redis 127.0.0.1:6379&gt; lrange mylist2 0 -1 1) &quot;hello&quot; redis 127.0.0.1:6379&gt; 9. lindex返回名称为key的list中index位置的元素 redis 127.0.0.1:6379&gt; lrange mylist5 0 -1 1) &quot;three&quot; 2) &quot;foo&quot; redis 127.0.0.1:6379&gt; lindex mylist5 0 &quot;three&quot; redis 127.0.0.1:6379&gt; lindex mylist5 1 &quot;foo&quot; redis 127.0.0.1:6379&gt; 10. llen返回key对应list的长度 redis 127.0.0.1:6379&gt; llen mylist5 (integer) 2 redis 127.0.0.1:6379&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[redis 整理（三）hash 类型]]></title>
      <url>%2F2014%2F08%2F08%2Fredis-datatype-hash%2F</url>
      <content type="text"><![CDATA[hash 类型简介redis hash是一个string类型的field和value的映射表。它的添加、删除操作都是0(1)(平均)。hash特别适合用于存储对象。相较于将对象的每个字段存成单个string类型，将一个对象存储在hash类型中会占用更少的内存，并且可以更方便的存取整个对象。省内存的原因是新建一个hash对象时开始是用zipmap来存储的。 hash 操作1. hset设置hash field为指定值，如果key不存在，则先创建。 redis 127.0.0.1:6379&gt; hset myhash field1 Hello (integer) 1 redis 127.0.0.1:6379&gt; 2. hsetnx设置hash field 为指定值，如果key 不存在，则先创建。如果field 已经存在，返回0，nx 是not exist 的意思。 redis 127.0.0.1:6379&gt; hsetnx myhash field &quot;Hello&quot; (integer) 1 redis 127.0.0.1:6379&gt; hsetnx myhash field &quot;Hello&quot; (integer) 0 redis 127.0.0.1:6379&gt; 第一次执行是成功的，但第二次执行相同的命令失败，原因是field 已经存在了。 3. hmset同时设置hash的多个field。 redis 127.0.0.1:6379&gt; hmset myhash field1 Hello field2 World OK redis 127.0.0.1:6379&gt; 4. hget获取指定的hash field。 redis 127.0.0.1:6379&gt; hget myhash field1 &quot;Hello&quot; redis 127.0.0.1:6379&gt; hget myhash field2 &quot;World&quot; redis 127.0.0.1:6379&gt; hget myhash field3 (nil) redis 127.0.0.1:6379&gt; 由于数据库没有field3，所以取到的是一个空值nil。 5. hmget获取全部指定的hash field。 redis 127.0.0.1:6379&gt; hmget myhash field1 field2 field3 1) &quot;Hello&quot; 2) &quot;World&quot; 3) (nil) redis 127.0.0.1:6379&gt; 由于数据库没有field3，所以取到的是一个空值nil。 6. hincrby指定的hash filed 加上给定值。 redis 127.0.0.1:6379&gt; hset myhash field3 20 (integer) 1 redis 127.0.0.1:6379&gt; hget myhash field3 &quot;20&quot; redis 127.0.0.1:6379&gt; hincrby myhash field3 -8 (integer) 12 redis 127.0.0.1:6379&gt; hget myhash field3 &quot;12&quot; redis 127.0.0.1:6379&gt; 例中将field3 的值从20 降到了12，即做了一个减8 的操作。 7. hexists测试指定field 是否存在。 redis 127.0.0.1:6379&gt; hexists myhash field1 (integer) 1 redis 127.0.0.1:6379&gt; hexists myhash field9 (integer) 0 redis 127.0.0.1:6379&gt; 通过上例可以说明field1 存在，但field9 是不存在的。 8. hlen返回指定hash 的field 数量。 redis 127.0.0.1:6379&gt; hlen myhash (integer) 4 redis 127.0.0.1:6379&gt; 通过上例可以看到myhash 中有4 个field。 9. hdel返回指定hash 的field 数量。 redis 127.0.0.1:6379&gt; hlen myhash (integer) 4 redis 127.0.0.1:6379&gt; hdel myhash field1 (integer) 1 redis 127.0.0.1:6379&gt; hlen myhash (integer) 3 redis 127.0.0.1:6379&gt; 10. hkeys返回hash 的所有field。 redis 127.0.0.1:6379&gt; hkeys myhash 1) &quot;field2&quot; 2) &quot;field&quot; 3) &quot;field3&quot; redis 127.0.0.1:6379&gt; 说明这个hash 中有3 个field 11. hvals返回hash 的所有value。 redis 127.0.0.1:6379&gt; hvals myhash 1) &quot;World&quot; 2) &quot;Hello&quot; 3) &quot;12&quot; redis 127.0.0.1:6379&gt; 说明这个hash 中有3 个field 12. hgetall获取某个hash 中全部的filed 及value redis 127.0.0.1:6379&gt; hgetall myhash 1) &quot;field2&quot; 2) &quot;World&quot; 3) &quot;field&quot; 4) &quot;Hello&quot; 5) &quot;field3&quot; 6) &quot;12&quot; redis 127.0.0.1:6379&gt; 可见，一下子将myhash 中所有的field 及对应的value 都取出来了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[redis 整理（二）String类型]]></title>
      <url>%2F2014%2F08%2F07%2Fredis-datatype-string%2F</url>
      <content type="text"><![CDATA[上文详细介绍了Redis数据库以及它的安装过程，及适用场景，已经了解，Redis数据库是基于内存的数据库，速度极快，本篇将介绍redis数据库的操作使用方法，Redis有七种数据类型：字符串，哈希表，链表，集合和有序集合 String 类型简介String是最简单的类型，可以理解成与Memcached是一模一样的类型，一个Key对应一个Value，可以完全实现Memcached的功能，而且效率要比Memcached高很多，同时可以设置Redis的定时数据持久化，操作日志的记录以及主从复制等功能！ 操作1. set设置Key对应的值为string类型的value。 例如设置一个name = zhangsan 的键值对，可以这样做： $ redis-cli redis 127.0.0.1:6379&gt; set name zhangsan OK redis 127.0.0.1:6379&gt; get name &quot;zhangsan&quot; redis 127.0.0.1:6379&gt; 2. setnx设置key 对应的值为string 类型的value。如果key 已经存在，返回0，nx 是not exist 的意思。 例如添加一个name= lisi 的键值对，可以这样做: redis 127.0.0.1:6379&gt; setnx name lisi (integer) 0 redis 127.0.0.1:6379&gt; get name &quot;lisi&quot; redis 127.0.0.1:6379&gt; 由于原来name 有一个对应的值，所以本次的修改不生效，且返回码是0。 3. setex设置一个键对应的值，并对此键值对设置一个有效期。 例如：指定一个键值对 result = success，并且设置一个有效期为10秒，我们来这样做： redis 127.0.0.1:6379&gt; set result 10 success OK redis 127.0.0.1:6379&gt; get result &quot;success&quot; redis 127.0.0.1:6379&gt; get result (nil) redis 127.0.0.1:6379&gt; 由于第二次调用已经超过10秒，所以无法取到result的值了！！！ 4. setrange设置指定键的值的子字符串。 例如：我现在要把 gang 的邮箱 finalsin@foxmail.com 改为 finalsin@sina.com redis 127.0.0.1:6379&gt; get gang &quot;finalsin@foxmail.com&quot; redis 127.0.0.1:6379&gt; setrange gang 9 sina.com (integer) 21 redis 127.0.0.1:6379&gt; get gang &quot;finalsin@sina.com&quot; redis 127.0.0.1:6379&gt; 5. mset同时设置多个键值对，成功返回ok表示所有键设置成功，失败则返回0表示所有键设置都不成功 例如：同时设置 王刚 的多个爱好： redis 127.0.0.1:6379&gt; mset hobby1 music hobby2 sport hobby3 girl OK redis 127.0.0.1:6379&gt; get hobby1 &quot;music&quot; redis 127.0.0.1:6379&gt; get hobby3 &quot;girl&quot; redis 127.0.0.1:6379&gt; 6. msetnx同时设置多个键值对，同样失败返回0表示所有键都没有设置成功，成功返回OK表示所有键都设置成功，但不同于mset的是本方法不会设置已经存在的键值对！ redis 127.0.0.1:6379&gt; get hobby1 &quot;music&quot; redis 127.0.0.1:6379&gt; get hobby3 &quot;girl&quot; redis 127.0.0.1:6379&gt; msetnx hobby1 tingge hobby4 hejiu (integer) 0 redis 127.0.0.1:6379&gt; get hobby4 (nil) redis 127.0.0.1:6379&gt; get hobby3 &quot;girl&quot; 可以看出如果这条命令返回0，那么里面操作都会回滚，都不会被执行。 7. get获取某个键对应的值，如果不存在则返回 nil redis 127.0.0.1:6379&gt; get hobby4 (nil) redis 127.0.0.1:6379&gt; get hobby3 &quot;girl&quot; 如上例，hobby3存在，并且值为”girl”，hobby4不存在，则返回 nil 8. getset设置某一个键的值，并且返回该键的旧值，如果该键不存在，则返回 nil，然后再设置新的值 例如： redis 127.0.0.1:6379&gt; getset hobby4 football (nil) redis 127.0.0.1:6379&gt; getset hobby3 basketball &quot;girl&quot; redis 127.0.0.1:6379&gt; get hobby4 &quot;football&quot; redis 127.0.0.1:6379&gt; get hobby3 &quot;basketball&quot; 9. getrange获取指定键的值的子字符串 例如： redis 127.0.0.1:6379&gt; getrange gang 0 7 &quot;finalsin&quot; redis 127.0.0.1:6379&gt; getrange gang -8 -1 &quot;sina.com&quot; redis 127.0.0.1:6379&gt; getrange gang 0 100 &quot;finalsin@sina.com&quot; 上例中，getrange jiege 0 4 表示获取 jiege 这个键的值的下标为 0~4 的所有字符 同样，getrange jiege -15 -1 表示获取 jiege 这个键的值的下标从后数第15个到最后一个的所有字符 而 getrange jiege 0 100 则表示全部输出 jiege 这个键的值的所有字符，因为最后一个字符的下标 小于 100， 当下标超出字符串长度时，将默认为是同方向的最大下标。 10. mget一次性获取多个键的值，如果键不存在，则返回 nil 例如： redis 127.0.0.1:6379&gt; mget hobby1 hobby2 hobby5 1) &quot;music&quot; 2) &quot;sport&quot; 3) (nil) redis 127.0.0.1:6379&gt; hobby5不存在，所以返回nil。 11. incr对一个键的值做加加操作，并返回新的值，如果该键的值类型不是int类型，将会报错，如果该键不存在，则设置该键为1 例如： redis 127.0.0.1:6379&gt; set age 20 OK redis 127.0.0.1:6379&gt; incr age (integer) 21 redis 127.0.0.1:6379&gt; get age &quot;21&quot; redis 127.0.0.1:6379&gt; get age1 (nil) redis 127.0.0.1:6379&gt; incr age1 (integer) 1 redis 127.0.0.1:6379&gt; get age1 &quot;1&quot; 12. incrby类似于incr，但是incrby可以指定增加的值 例如： redis 127.0.0.1:6379&gt; incrby age 5 (integer) 26 redis 127.0.0.1:6379&gt; get age &quot;26&quot; redis 127.0.0.1:6379&gt; incrby age -1 (integer) 25 redis 127.0.0.1:6379&gt; get age &quot;25&quot; 可以看到，5代表给age键增加5，而-1表示给age键减1，即正数为加，负数为减 13. decr对某一个键做减减操作，同incr 例如： redis 127.0.0.1:6379&gt; set age 20 OK redis 127.0.0.1:6379&gt; decr age (integer) 19 redis 127.0.0.1:6379&gt; get age &quot;19&quot; redis 127.0.0.1:6379&gt; get age1 (nil) redis 127.0.0.1:6379&gt; decr age1 (integer) -1 redis 127.0.0.1:6379&gt; get age1 &quot;-1&quot; 14. decrby同incrby，给某一键减去指定的值 redis 127.0.0.1:6379&gt; decrby age 5 (integer) 14 redis 127.0.0.1:6379&gt; get age &quot;14&quot; decrby 完全是为了可读性，我们完全可以通过incrby 一个负值来实现同样效果，反之一样。 15. append给指定key 的字符串值追加value,返回新字符串值的长度。 例如： redis 127.0.0.1:6379&gt; set name wanggang OK redis 127.0.0.1:6379&gt; get name &quot;wanggang&quot; redis 127.0.0.1:6379&gt; append name @wg.org (integer) 15 redis 127.0.0.1:6379&gt; get name &quot;wanggang@wg.org&quot; 16. strlen取指定key 的value 值的长度。 例如： redis 127.0.0.1:6379&gt; get name &quot;wanggang@wg.org&quot; redis 127.0.0.1:6379&gt; strlen name (integer) 15 redis 127.0.0.1:6379&gt; get age &quot;20&quot; redis 127.0.0.1:6379&gt; strlen age (integer) 2 好了，这就是String类型的所有操作]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[redis 整理（一）简介及安装]]></title>
      <url>%2F2014%2F08%2F06%2Fredis-introduction-install%2F</url>
      <content type="text"><![CDATA[NoSQL 简介NoSQL更注重的是对海量数据存取的性能、分布式、扩展性支持上，并不需要传统关系数据库的一些特征，例如：Schema、事务、完整SQL查询支持等等，因此在分布式环境下的性能相对与传统的关系数据库有较大的提升。Redis就是NoSQL这个大家族中的一份子，它是一个开源的使用ANSI C语言编写、支持网络、可基于内存也可持久化的日志型、Key-Value数据库，并提供多种语言的API。 Redis 简介Redis is an open source, BSD licensed, advanced key-value cache and store. It is often referred to as a data structure server since keys can contain strings, hashes, lists, sets, sorted sets, bitmaps and hyperloglogs. Redis是一个开源的，高级的键值式存储数据库。它通常被称为一个数据结构服务器可以包含字符串，哈希表，链表，集合和有序集合。 为了实现其出色的表现，Redis是工作在内存中的数据集。您还可以根据您的具体的使用情况，每隔一段时间或执行命令时将数据集写入到磁盘，并且添加到日志中。Redis还支持主从复制，并且配置起来很简单，第一次同步就可以无阻塞的达到极快的速度，在网络断开的时候可以自动重连等等。另外它的简单的检查与设置机制，发布(Publish)与订阅(Subscribe)和配置设置的特性使它看起来像是一个缓存。 Redis 适用场景1、取最新N 个数据的操作比如典型的取你网站的最新文章，通过下面方式，我们可以将最新的5000 条评论的ID 放在Redis 的List 集合中，并将超出集合部分从数据库获取。 2、排行榜应用，取TOP N 操作这个需求与上面需求的不同之处在于，前面操作以时间为权重，这个是以某个条件为权重，比如按顶的次数排序，这时候就需要我们的sorted set 出马了，将你要排序的值设置成sorted set 的score，将具体的数据设置成相应的value，每次只需要执行一条ZADD 命令即可。 3、需要精准设定过期时间的应用比如你可以把上面说到的sorted set 的score 值设置成过期时间的时间戳，那么就可以简单地通过过期时间排序，定时清除过期数据了，不仅是清除Redis 中的过期数据，你完全可以把Redis 里这个过期时间当成是对数据库中数据的索引，用Redis 来找出哪些数据需要过期删除，然后再精准地从数据库中删除相应的记录。 4、计数器应用Redis 的命令都是原子性的，你可以轻松地利用INCR，DECR 命令来构建计数器系统。 5、Uniq 操作，获取某段时间所有数据排重值这个使用Redis 的set 数据结构最合适了，只需要不断地将数据往set 中扔就行了，set 意为集合，所以会自动排重。 6、实时系统，反垃圾系统通过上面说到的set 功能，你可以知道一个终端用户是否进行了某个操作，可以找到其操作的集合并进行分析统计对比等。没有做不到，只有想不到。 7、Pub/Sub 构建实时消息系统Redis 的Pub/Sub 系统可以构建实时的消息系统，比如很多用Pub/Sub 构建的实时聊天系统的例子。 8、构建队列系统使用list 可以构建队列系统，使用sorted set 甚至可以构建有优先级的队列系统。 9、缓存这个不必说了，性能优于Memcached，数据结构更多样化。 Redis 安装第一步，下载Redis，可以通过官网下载最新版本的源代码包第二步，将下载好的源代码包上传到我们的Linux主机中，解压，编译安装$ tar zxf redis-2.8.13.tar.gz $ cd redis-2.8.13 $ make $ cd src &amp;&amp; make all 第三步，启动redis服务$ src/redis-server 第四步，测试redis$ redis－cli redis 127.0.0.1:6379&gt; set foo 123 redis 127.0.0.1:6379&gt; get foo &quot;123&quot; redis 127.0.0.1:6379&gt; exit Redis服务器的端口默认是6379，但是你会发现Redis服务会一直占用我们当前登录Linux的SESSION，那能否像Mysql或者是MongoDB一样在后台执行Redis进程呢，当然可以，我们只需要更改Redis的配置文件，并且启动的时候指定配置文件即可！ 如果是一个专业的DBA，那么实例启动时会加很多参数以便是系统运行的非常稳定，这样就可能在启动时在Redis后面加一个参数，以指定配置文件的路径，就像mysql一样的读取启动配置文件的方式来启动数据库。 Redis的配置文件redis.conf里面都有什么： #是否作为守护进程运行 daemonize yes #配置 pid 的存放路径及文件名,默认为当前路径下 pidfile redis.pid #Redis 默认监听端口 port 6379 #客户端闲置多少秒后,断开连接 timeout 300 #日志显示级别 loglevel verbose #指定日志输出的文件名,也可指定到标准输出端口 logfile stdout #设置数据库的数量,默认连接的数据库是 0,可以通过 select N 来连接不同的数据库 databases 16 #保存数据到 disk 的策略 #当有一条 Keys 数据被改变是,900 秒刷新到 disk 一次 save 900 1 #当有 10 条 Keys 数据被改变时,300 秒刷新到 disk 一次 save 300 10 #当有 1w 条 keys 数据被改变时,60 秒刷新到 disk 一次 save 60 10000 #当 dump .rdb 数据库的时候是否压缩数据对象 rdbcompression yes #dump 数据库的数据保存的文件名 dbfilename dump.rdb #Redis 的工作目录 dir /home/falcon/redis-2.0.0/ ########### Replication ##################### #Redis 的复制配置 # slaveof &lt;masterip&gt; &lt;masterport&gt; # masterauth &lt;master-password&gt; ############## SECURITY ########### # requirepass foobared ############### LIMITS ############## #最大客户端连接数 # maxclients 128 #最大内存使用率 # maxmemory &lt;bytes&gt; ########## APPEND ONLY MODE ######### #是否开启日志功能 appendonly no # 刷新日志到 disk 的规则 # appendfsync always appendfsync everysec # appendfsync no ################ VIRTUAL MEMORY ########### #是否开启 VM 功能 vm-enabled no # vm-enabled yes vm-swap-file logs/redis.swap vm-max-memory 0 vm-page-size 32 vm-pages 134217728 vm-max-threads 4 ############# ADVANCED CONFIG ############### glueoutputbuf yes hash-max-zipmap-entries 64 hash-max-zipmap-value 512 #是否重置 Hash 表 activerehashing yes 可以看到第一条就是启动后台进程启动Redis服务，将其设置为yes，就会在后台运行Redis服务！ 启动的时候来指定redis的配置文件 $ /usr/local/redis/bin/redis-server /usr/local/redis/redis.conf 开机启动1.配置将以下代码存为redis,放到/etc/init.d/下面,注意修改相应的路径 # # chkconfig: - 90 10 # description: Redis is an open source, advanced key-value store. # # processname: redis-server # config: /etc/redis.conf # pidfile: /var/run/redis.pid PATH=/usr/local/bin:/sbin:/usr/bin:/bin REDISPORT=6379 EXEC=/usr/local/bin/redis-server REDIS_CLI=/usr/local/bin/redis-cli PIDFILE=/var/run/redis.pid CONF=&quot;/etc/redis.conf&quot; case &quot;$1&quot; in start) if [ -f $PIDFILE ] then echo -n &quot;$PIDFILE exists, process is already running or crashed\n&quot; else echo -n &quot;Starting Redis server...\n&quot; $EXEC $CONF fi ;; stop) if [ ! -f $PIDFILE ] then echo -n &quot;$PIDFILE does not exist, process is not running\n&quot; else PID=$(cat $PIDFILE) echo -n &quot;Stopping ...\n&quot; $REDIS_CLI -p $REDISPORT SHUTDOWN while [ -x ${PIDFILE} ] do echo &quot;Waiting for Redis to shutdown ...&quot; sleep 1 done echo &quot;Redis stopped&quot; fi ;; esac 2.修改配置文件权限$ chmod a+x /etc/init.d/redis 3.设定开机启动$ chkconfig redis on 4.启动，停止redis服务$ service redis start #或者 /etc/init.d/redis start $ service redis stop #或者 /etc/init.d/redis stop]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CAS 服务器端取消 https的配置 方法]]></title>
      <url>%2F2014%2F07%2F14%2Fcas-disable-ssl%2F</url>
      <content type="text"><![CDATA[需要修改的配置文件有：WEB-INF/deployerConfigContext.xml 、 WEB-INF/spring-configuration/ticketGrantingTicketCookieGenerator.xml 、WEB-INF\spring-configuration\warnCookieGenerator.xml 详细配置修改如下： 1 、 WEB-INF/deployerConfigContext.xml 在&lt; bean class = &quot;org.jasig.cas.authentication.handler.support.HttpBasedServiceCredentialsAuthenticationHandler&quot; p:httpClient-ref = &quot;httpClient&quot; /&gt; 增加参数 p:requireSecure=”false” ，是否需要安全验证，即 HTTPS ， false 为不采用 如下： &lt; bean class = &quot;org.jasig.cas.authentication.handler.support.HttpBasedServiceCredentialsAuthenticationHandler&quot; p:httpClient-ref = &quot;httpClient&quot; p:requireSecure= &quot;false&quot; /&gt; 2 、 WEB-INF/spring-configuration/ticketGrantingTicketCookieGenerator.xml 修改 p:cookieSecure=”true” 为 p:cookieSecure=” false “ ， 即不需要安全 cookie 如下部分：&lt; bean id = &quot;ticketGrantingTicketCookieGenerator&quot; class = &quot;org.jasig.cas.web.support.CookieRetrievingCookieGenerator&quot; p:cookieSecure = &quot; false &quot; p:cookieMaxAge = &quot;-1&quot; p:cookieName = &quot;CASTGC&quot; p:cookiePath = &quot;/cas&quot; /&gt; 3 、 WEB-INF\spring-configuration\warnCookieGenerator.xml修改 p:cookieSecure=”true” 为 p:cookieSecure=” false “ ， 即不需要安全 cookie 结果如下： &lt; bean id = &quot;warnCookieGenerator&quot; class = &quot;org.jasig.cas.web.support.CookieRetrievingCookieGenerator&quot; p:cookieSecure = &quot; false &quot; p:cookieMaxAge = &quot;-1&quot; p:cookieName = &quot;CASPRIVACY&quot; p:cookiePath = &quot;/cas&quot; /&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CAS logout 注销]]></title>
      <url>%2F2014%2F07%2F12%2Fcas-logout%2F</url>
      <content type="text"><![CDATA[网友不停问为什么CAS Logout后，仍然能够访问应用？http://dev2dev.bea.com.cn/bbs/thread.jspa?forumID=29304&amp;threadID=37715&amp;messageID=221727#221727 假设有webapp1, webapp2, cas server，webapp1, webapp2均受cas server保护，首先，在这里简单解释一下： 第1种不能logout的情况： 登录了WebApp1，redirect到caserver，casserver认证后，再redirect到webapp1，ok！ http方式 lougout casserver1，即http://yale_casserver:8080/cas/lougout 显示logout成功 访问webapp2，还能访问！这是非常正常的一种情况，因为你不通过https来注销，casserver怎么”杀”掉它通过https发给你的TGC Cookie? 第2种不能logout的情况： 登录了WebApp1，redirect到caserver,casserver认证后，再redirect到webapp1，ok！ https方式 lougout casserver1，即https://yale_casserver:8443/cas/lougout 显示logout成功 访问webapp1，还能访问！访问webapp2，不能访问，重定向到casserver要求登录！这也是非常正常的一种情况，因为你已经能够访问，你继续可以继续访问，CASLogout不能阻止你访问webapp1，它只能阻止你访问webapp2，因为你已经被允许访问webapp1，而webapp2则还没有，如果你在(1)的时候，顺带也访问webapp2，那么你的注销将毫无作用了，CAS无法阻止你访问这两个webapp，因为你有Service Ticket。 如果你对此费解，那时因为你已为Logout就是退出系统，那我只能表示遗憾，因为CAS Logout的作用不是这样，它的作用是阻止你继续通过TGC（它简单地清楚了IE的TGC Cookie）来获取ST，阻止你获取通向其他web应用的Ticket。 所以，用完webapp1的时候，注销，然后再关闭掉IE就彻底Logout了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SSO实现机制:Cookie机制和Session机制]]></title>
      <url>%2F2014%2F07%2F11%2Fcas-implementation-mechanism-cookie-session%2F</url>
      <content type="text"><![CDATA[SSO 的实现机制不尽相同，大体分可为 Cookie 机制和 Session 机制两大类。 WebLogic 通过 Session 共享认证信息。 Session 是一种服务器端机制，当客户端访问服务器时，服务器为客户端创建一个惟一的 SessionID ，以使在整个交互过程中始终保持状态，而交互的信息则可由应用自行指定，因此 用 Session 方式实现 SSO ，不能在多个浏览器之间实现单点登录，但却可以跨域 。 WebSphere 通过 Cookie 记录认证信息。 Cookie 是一种客户端机制，它存储的内容主要包括 : 名字、值、过期时间、路径和域，路径与域合在一起就构成了 Cookie 的作用范围，因此 用 Cookie 方式可实现 SSO ，但域名必须相同 。 目前 大部分 SSO 产品采用的是 Cookie 机制。 目前能够找到的最好的开源单点登录产品 CAS 也是采用 Cookie 机制。 CAS 单点登录系统最早由耶鲁大学开发。 2004 年 12 月， CAS 成为 JA-SIG 中的一个项目。 JA-SIG 的全称是 Java Architectures Special Interest Group ，是在高校中推广和探讨基于 Java 的开源技术的一个组织。 CAS 的优点很多，例如设计理念先进、体系结构合理、配置简单、客户端支持广泛、技术成熟等等。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CAS 登录流程httpwatch解析]]></title>
      <url>%2F2014%2F07%2F10%2Fcas-login-flow-httpwatch%2F</url>
      <content type="text"><![CDATA[cas sso 登录流程解析，使用httpwatch查看 1. 第一次访问 http://localhost:8080/aCLIENT：没票据且SESSION中没有Assertion所以跳转至CAS CAS：拿不到TGC故要求用户登录 2. 认证成功后回跳CAS：通过TGT生成ST发给客户端，客户端保存TGC，并重定向到http://localhost:8080/a CLIENT：带有票据所以不跳转只是后台发给CAS验证票据（浏览器中无法看到这一过程） 3. 第一次访问 http://localhost:8080/bCLIENT：没票据且SESSION中没有消息所以跳转至CAS CAS：从客户端取出TGC，如果TGC有效则给用户ST并后台验证ST，从而SSO。【如果失效重登录或注销时，怎么通知其它系统更新SESSION信息呢？？TicketGrantingTicketImpl类grantServiceTicket方法里this.services.put(id, service);可见CAS端已经记录了当前登录的子系统】 4. 再次访问 http://localhost:8080/aCLIENT：没票据但是SESSION中有(Assertion)消息故不跳转也不用发CAS验证票据，允许用户访问 CAS Authentication Filter认证： if (CommonUtils.isBlank(ticket) &amp;&amp; request.setAttribute(CONST_CAS_ASSERTION, assertion)== null &amp;&amp; !wasGatewayed) { //即没有票据且没有SESSION通过信息则跳转 } CAS Validation Filter认证： if (CommonUtils.isNotBlank(ticket)) { //即如果发现ST则发给CAS认证，否则不认证。 final Assertion assertion = this.ticketValidator.validate( ticket, constructServiceUrl(request, response)); request.setAttribute(CONST_CAS_ASSERTION, assertion);//认证通过后将信息保存SESSION中 }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CAS 服务器端配置文件]]></title>
      <url>%2F2014%2F07%2F08%2Fcas-server-config%2F</url>
      <content type="text"><![CDATA[CAS 服务器端主要配置文件如下： login-webflow.xml：其中内容指定了当访问cas/login时的程序流程，初始“initialFlowSetup” cas-servlet.xml：servlet与class对应关系 deployerConfigContext.xml：认证管理器相关 cas.properties：系统属性设置 applicationContext.xml：系统属性相关 argumentExtractorsConfiguration.xml：不是很了解它的用途 ticketExpirationPolicies.xml：ticket过期时间设置 ticketGrantingTicketCookieGenerator.xml：TGT cookie属性相关，是否支持http也在这儿修改 ticketRegistry.xml：保存ticket的类相关设置 uniqueIdGenerators.xml：ticket自动生成类设置 warnCookieGenerator.xml：同ticketGrantingTicketCookieGenerator.xml，生成的 cookie名为CASPRIVACY /login ：当访问/login时，会调用login-webflow.xml中的流程图： ##/serviceValidate:对应的处理类是org.jasig.cas.web.ServiceValidateController，主要负责对service ticket的验证，失败返回casServiceValidationFailure.jsp，成功返回casServiceValidationSuccess.jsp对service ticket的验证是通过client端向server端发送http（或https）实现的逻辑： 通过由client端传来的ticket到DefaultTicketRegistry中获取缓存的ServiceTicketImpl对象，并判断其是否已经过期（ST过期时间默认是5分钟，TGT默认是2个小时，可以在ticketExpirationPolicies.xml中进行修改）以及与当前service的id是否相一，以上都满足则表示验证通过。 通过ServiceTicketImpl对象获取到登录之后的Authentication对象，借助于它生成ImmutableAssertionImpl对象并返回 成功返回 CAS数据流程Credentials–&gt;Principal–&gt;Authentication 定义自己的AuthenticationHandler在中心认证进行认证的过程中会调用deployerConfigContext.xml中设置的AuthenticationHandler来进行认证工作。 &lt;property name=&quot;authenticationHandlers&quot;&gt; &lt;list&gt; &lt;!-- This is the authentication handler that authenticates services by means of callback via SSL, thereby validating a server side SSL certificate. --&gt; &lt;bean class=&quot;org.jasig.cas.authentication.handler.support.HttpBasedServiceCredentialsAuthenticationHandler&quot; p:httpClient-ref=&quot;httpClient&quot; /&gt; &lt;!-- This is the authentication handler declaration that every CAS deployer will need to change before deploying CAS into production. The default SimpleTestUsernamePasswordAuthenticationHandler authenticates UsernamePasswordCredentials where the username equals the password. You will need to replace this with an AuthenticationHandler that implements your local authentication strategy. You might accomplish this by coding a new such handler and declaring edu.someschool.its.cas.MySpecialHandler here, or you might use one of the handlers provided in the adaptors modules. --&gt; &lt;bean class=&quot;org.jasig.cas.authentication.handler.support.SimpleTestUsernamePasswordAuthenticationHandler&quot; /&gt; &lt;bean class=&quot;com.goldarmor.live800.cas.Live800CasAuthenticationHandler&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;casDataSource&quot; /&gt; &lt;/bean&gt; &lt;/list &lt;/property&gt; &lt;property name=&quot;authenticationHandlers&quot;&gt; &lt;list&gt; &lt;!-- This is the authentication handler that authenticates services by means of callback via SSL, thereby validating a server side SSL certificate. --&gt; &lt;bean class=&quot;org.jasig.cas.authentication.handler.support.HttpBasedServiceCredentialsAuthenticationHandler&quot; p:httpClient-ref=&quot;httpClient&quot; /&gt; &lt;!-- This is the authentication handler declaration that every CAS deployer will need to change before deploying CAS into production. The default SimpleTestUsernamePasswordAuthenticationHandler authenticates UsernamePasswordCredentials where the username equals the password. You will need to replace this with an AuthenticationHandler that implements your local authentication strategy. You might accomplish this by coding a new such handler and declaring edu.someschool.its.cas.MySpecialHandler here, or you might use one of the handlers provided in the adaptors modules. --&gt; &lt;bean class=&quot;org.jasig.cas.authentication.handler.support.SimpleTestUsernamePasswordAuthenticationHandler&quot; /&gt; &lt;bean class=&quot;com.goldarmor.live800.cas.Live800CasAuthenticationHandler&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;casDataSource&quot; /&gt; &lt;/bean&gt; &lt;/list&gt; &lt;/property&gt; 如上，我们定义了3个AuthenticationHandler，这正是CAS的一个，通过配置，我们可以实现针对不同的应用提供不同的认证方式，这样可以实现任意的中心认证。再来看看AuthenticationHandler的代码 /** * Method to determine if the credentials supplied are valid. * * @param credentials The credentials to validate. * @return true if valid, return false otherwise. * @throws AuthenticationException An AuthenticationException can contain * details about why a particular authentication request failed. */ boolean authenticate(Credentials credentials) throws AuthenticationException; /** * Method to check if the handler knows how to handle the credentials * provided. It may be a simple check of the Credentials class or something * more complicated such as scanning the information contained in the * Credentials object. * * @param credentials The credentials to check. * @return true if the handler supports the Credentials, false othewrise. */ boolean supports(Credentials credentials); /** * Method to determine if the credentials supplied are valid. * * @param credentials The credentials to validate. * @return true if valid, return false otherwise. * @throws AuthenticationException An AuthenticationException can contain * details about why a particular authentication request failed. */ boolean authenticate(Credentials credentials) throws AuthenticationException; /** * Method to check if the handler knows how to handle the credentials * provided. It may be a simple check of the Credentials class or something * more complicated such as scanning the information contained in the * Credentials object. * * @param credentials The credentials to check. * @return true if the handler supports the Credentials, false othewrise. */ boolean supports(Credentials credentials); 我们要做的就是实现这俩个方法而已，特别提醒：可以在cas-servlet.xml中设置你所使用的Credentials，如下：（其中的p:formObjectClass值，如果不指定默认使用UsernamePasswordCredentials） &lt;bean id=&quot;authenticationViaFormAction&quot; class=&quot;org.jasig.cas.web.flow.AuthenticationViaFormAction&quot; p:formObjectClass=&quot;com.goldarmor.live800.cas.Live800CasCredentials&quot; p:centralAuthenticationService-ref=&quot;centralAuthenticationService&quot; p:warnCookieGenerator-ref=&quot;warnCookieGenerator&quot; /&gt; &lt;bean id=&quot;authenticationViaFormAction&quot; class=&quot;org.jasig.cas.web.flow.AuthenticationViaFormAction&quot; p:formObjectClass=&quot;com.goldarmor.live800.cas.Live800CasCredentials&quot; p:centralAuthenticationService-ref=&quot;centralAuthenticationService&quot; p:warnCookieGenerator-ref=&quot;warnCookieGenerator&quot; /&gt; 定义自己的credentialsToPrincipalResolvers通过AuthenticationHandler的认证后，会调用在deployerConfigContext.xml中配置的credentialsToPrincipalResolvers来处理Credentials，生成Principal对象： &lt;property name=&quot;credentialsToPrincipalResolvers&quot;&gt; &lt;list&gt; &lt;!-- UsernamePasswordCredentialsToPrincipalResolver supports the UsernamePasswordCredentials that we use for /login by default and produces SimplePrincipal instances conveying the username from the credentials. If you&apos;ve changed your LoginFormAction to use credentials other than UsernamePasswordCredentials then you will also need to change this bean declaration (or add additional declarations) to declare a CredentialsToPrincipalResolver that supports the Credentials you are using. --&gt; &lt;bean class=&quot;org.jasig.cas.authentication.principal.UsernamePasswordCredentialsToPrincipalResolver&quot; /&gt; &lt;!-- HttpBasedServiceCredentialsToPrincipalResolver supports HttpBasedCredentials. It supports the CAS 2.0 approach of authenticating services by SSL callback, extracting the callback URL from the Credentials and representing it as a SimpleService identified by that callback URL. If you are representing services by something more or other than an HTTPS URL whereat they are able to receive a proxy callback, you will need to change this bean declaration (or add additional declarations). --&gt; &lt;bean class=&quot;org.jasig.cas.authentication.principal.HttpBasedServiceCredentialsToPrincipalResolver&quot; /&gt; &lt;bean class=&quot;com.goldarmor.live800.cas.Live800CasCredentialsToPrincipalResolver&quot;/&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=&quot;credentialsToPrincipalResolvers&quot;&gt; &lt;list&gt; &lt;!-- UsernamePasswordCredentialsToPrincipalResolver supports the UsernamePasswordCredentials that we use for /login by default and produces SimplePrincipal instances conveying the username from the credentials. If you&apos;ve changed your LoginFormAction to use credentials other than UsernamePasswordCredentials then you will also need to change this bean declaration (or add additional declarations) to declare a CredentialsToPrincipalResolver that supports the Credentials you are using. --&gt; &lt;bean class=&quot;org.jasig.cas.authentication.principal.UsernamePasswordCredentialsToPrincipalResolver&quot; /&gt; &lt;!-- HttpBasedServiceCredentialsToPrincipalResolver supports HttpBasedCredentials. It supports the CAS 2.0 approach of authenticating services by SSL callback, extracting the callback URL from the Credentials and representing it as a SimpleService identified by that callback URL. If you are representing services by something more or other than an HTTPS URL whereat they are able to receive a proxy callback, you will need to change this bean declaration (or add additional declarations). --&gt; &lt;bean class=&quot;org.jasig.cas.authentication.principal.HttpBasedServiceCredentialsToPrincipalResolver&quot; /&gt; &lt;bean class=&quot;com.goldarmor.live800.cas.Live800CasCredentialsToPrincipalResolver&quot;/&gt; &lt;/list&gt; &lt;/property&gt; 如上：我们也可以像定义AuthenticationHandler一样，可以定义多个credentialsToPrincipalResolvers来处理Credentials，返回你所需要的Principal对象，下面来看看credentialsToPrincipalResolvers的方法： /** * Turn Credentials into a Principal object by analyzing the information * provided in the Credentials and constructing a Principal object based on * that information or information derived from the Credentials object. * * @param credentials from which to resolve Principal * @return resolved Principal, or null if the principal could not be resolved. */ Principal resolvePrincipal(Credentials credentials); /** * Determine if a credentials type is supported by this resolver. This is * checked before calling resolve principal. * * @param credentials The credentials to check if we support. * @return true if we support these credentials, false otherwise. */ boolean supports(Credentials credentials); /** * Turn Credentials into a Principal object by analyzing the information * provided in the Credentials and constructing a Principal object based on * that information or information derived from the Credentials object. * * @param credentials from which to resolve Principal * @return resolved Principal, or null if the principal could not be resolved. */ Principal resolvePrincipal(Credentials credentials); /** * Determine if a credentials type is supported by this resolver. This is * checked before calling resolve principal. * * @param credentials The credentials to check if we support. * @return true if we support these credentials, false otherwise. */ boolean supports(Credentials credentials); 在CAS验证的时候，通过访问/serviceValidate可知：验证成功之后返回的casServiceValidationSuccess.jsp中的数据来源于Assertion，下面来看看它的代码： List&lt;Authentication&gt; getChainedAuthentications(); /** * True if the validated ticket was granted in the same transaction as that * in which its grantor GrantingTicket was originally issued. * * @return true if validated ticket was granted simultaneous with its * grantor&apos;s issuance */ boolean isFromNewLogin(); /** * Method to obtain the service for which we are asserting this ticket is * valid for. * * @return the service for which we are asserting this ticket is valid for. */ Service getService(); List&lt;Authentication&gt; getChainedAuthentications(); /** * True if the validated ticket was granted in the same transaction as that * in which its grantor GrantingTicket was originally issued. * * @return true if validated ticket was granted simultaneous with its * grantor&apos;s issuance */ boolean isFromNewLogin(); /** * Method to obtain the service for which we are asserting this ticket is * valid for. * * @return the service for which we are asserting this ticket is valid for. */ Service getService(); 通过getChainedAuthentications()方法，我们可以得到Authentication对象列表，再看看Authentication的代码： /** * Method to obtain the Principal. * * @return a Principal implementation */ Principal getPrincipal(); /** * Method to retrieve the timestamp of when this Authentication object was * created. * * @return the date/time the authentication occurred. */ Date getAuthenticatedDate(); /** * Attributes of the authentication (not the Principal). * @return the map of attributes. */ Map&lt;String, Object&gt; getAttributes(); /** * Method to obtain the Principal. * * @return a Principal implementation */ Principal getPrincipal(); /** * Method to retrieve the timestamp of when this Authentication object was * created. * * @return the date/time the authentication occurred. */ Date getAuthenticatedDate(); /** * Attributes of the authentication (not the Principal). * @return the map of attributes. */ Map&lt;String, Object&gt; getAttributes(); 而这其中的Principal就来源于上面提到的由credentialsToPrincipalResolvers处理得到的Principal对象，最后看一下Principal的代码，我们只要再做一个实现他的代码，整个CAS Server就可以信手拈来了，呵呵 /** * Returns the unique id for the Principal * @return the unique id for the Principal. */ String getId(); /** * * @return */ Map&lt;String, Object&gt; getAttributes(); /** * Returns the unique id for the Principal * @return the unique id for the Principal. */ String getId(); /** * * @return */ Map&lt;String, Object&gt; getAttributes(); 我们还可以自定义自己的casServiceValidationSuccess.jsp和casLoginView.jsp页面等，具体的操作办法也是最简单的办法就是备份以前的页面之后修改成自己需要的页面。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CAS-PGTIOU]]></title>
      <url>%2F2014%2F07%2F06%2Fcas-PGTIOU%2F</url>
      <content type="text"><![CDATA[CAS中的PGTIOU全称:Proxy Granting Ticket I Owe You ##PGTIOU作用：CAS调用Call back 返回 PGTIOU和PGT，其它人也可以调用该URL并传这两个参数，如果proxy不通过其它途径获取PGTIOU对call back返回的进行校验，就会造成被恶意干扰而取得不正确的PGT。 为什么要PGTURL呢？为什么不是验证St时直接返回PGT？主要是因为：假如hacker获取了ST（有效的），那么其他人就可以通过ST到Server验证并获取PGT，这样导致所有应用都可以访问，而不只是ST所对应的服务了。CAS要求PGTURL必须为Https，可以保证CAS回调时信任该URL（有PGTURL服务的证书）。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CAS Ticket票据:TGT、ST、PGT、PT、PGTIOU]]></title>
      <url>%2F2014%2F07%2F05%2Fcas-term-relationship%2F</url>
      <content type="text"><![CDATA[CAS的核心就是其Ticket，及其在Ticket之上的一系列处理操作。CAS的主要票据有TGT、ST、PGT、PGTIOU、PT，其中TGT、ST是CAS1.0协议中就有的票据，PGT、PGTIOU、PT是CAS2.0协议中有的票据。 1、术语解释 TGT（Ticket Grangting Ticket）： TGT是CAS为用户签发的登录票据，拥有了TGT，用户就可以证明自己在CAS成功登录过。TGT封装了Cookie值以及此Cookie值对应的用户信息。用户在CAS认证成功后，CAS生成cookie（叫TGC），写入浏览器，同时生成一个TGT对象，放入自己的缓存，TGT对象的ID就是cookie的值。当HTTP再次请求到来时，如果传过来的有CAS生成的cookie，则CAS以此cookie值为key查询缓存中有无TGT ，如果有的话，则说明用户之前登录过，如果没有，则用户需要重新登录。 TGC （Ticket-granting cookie）： 存放用户身份认证凭证的cookie，在浏览器和CAS Server间通讯时使用，并且只能基于安全通道传输（Https），是CAS Server用来明确用户身份的凭证。 ST（Service Ticket） ST是CAS为用户签发的访问某一service的票据。用户访问service时，service发现用户没有ST，则要求用户去CAS获取ST。用户向CAS发出获取ST的请求，如果用户的请求中包含cookie，则CAS会以此cookie值为key查询缓存中有无TGT，如果存在TGT，则用此TGT签发一个ST，返回给用户。用户凭借ST去访问service，service拿ST去CAS验证，验证通过后，允许用户访问资源。 PGT（Proxy Granting Ticket） Proxy Service的代理凭据。用户通过CAS成功登录某一Proxy Service后，CAS生成一个PGT对象，缓存在CAS本地，同时将PGT的值（一个UUID字符串）回传给Proxy Service，并保存在Proxy Service里。Proxy Service拿到PGT后，就可以为Target Service（back-end service）做代理，为其申请PT。 PGTIOU（全称 Proxy Granting Ticket I Owe You） PGTIOU是CAS协议中定义的一种附加票据，它增强了传输、获取PGT的安全性。PGT的传输与获取的过程：Proxy Service调用CAS的serviceValidate接口验证ST成功后，CAS首先会访问pgtUrl指向的https url，将生成的 PGT及PGTIOU传输给proxy service，proxy service会以PGTIOU为key，PGT为value，将其存储在Map中；然后CAS会生成验证ST成功的xml消息，返回给Proxy Service，xml消息中含有PGTIOU，proxy service收到Xml消息后，会从中解析出PGTIOU的值，然后以其为key，在map中找出PGT的值，赋值给代表用户信息的Assertion对象的pgtId，同时在map中将其删除。 PT（Proxy Ticket） PT是用户访问Target Service（back-end service）的票据。如果用户访问的是一个Web应用，则Web应用会要求浏览器提供ST，浏览器就会用cookie去CAS获取一个ST，然后就可以访问这个Web应用了。如果用户访问的不是一个Web应用，而是一个C/S结构的应用，因为C/S结构的应用得不到cookie，所以用户不能自己去CAS获取ST，而是通过访问proxy service的接口，凭借proxy service的PGT去获取一个PT，然后才能访问到此应用。 2、TGT、ST、PGT、PT之间关系 ST是TGT签发的。用户在CAS上认证成功后，CAS生成TGT，用TGT签发一个ST，ST的ticketGrantingTicket属性值是TGT对象，然后把ST的值redirect到客户应用。 PGT是ST签发的。用户凭借ST去访问Proxy service，Proxy service去CAS验证ST（同时传递PgtUrl参数给CAS），如果ST验证成功，则CAS用ST签发一个PGT，PGT对象里的ticketGrantingTicket是签发ST的TGT对象。 PT是PGT签发的。Proxy service代理back-end service去CAS获取PT的时候，CAS根据传来的pgt参数，获取到PGT对象，然后调用其grantServiceTicket方法，生成一个PT对象。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CAS实现SSO单点登录原理]]></title>
      <url>%2F2014%2F07%2F03%2Fcas-sso-principle%2F</url>
      <content type="text"><![CDATA[1. CAS 简介1.1. What is CAS ？CAS （ Central Authentication Service ） 是 Yale 大学发起的一个企业级的、开源的项目，旨在为 Web 应用系统提供一种可靠的单点登录解决方法（属于 Web SSO ）。CAS 开始于 2001 年， 并在 2004 年 12 月正式成为 JA-SIG 的一个项目。 1.2. 主要特性 开源的、多协议的 SSO 解决方案； Protocols ： Custom Protocol 、 CAS 、 OAuth 、 OpenID 、 RESTful API 、 SAML1.1 、 SAML2.0 等。 支持多种认证机制： Active Directory 、 JAAS 、 JDBC 、 LDAP 、 X.509 Certificates 等； 安全策略：使用票据（ Ticket ）来实现支持的认证协议； 支持授权：可以决定哪些服务可以请求和验证服务票据（ Service Ticket ）； 提供高可用性：通过把认证过的状态数据存储在 TicketRegistry 组件中，这些组件有很多支持分布式环境的实现，如： BerkleyDB 、 Default 、 EhcacheTicketRegistry 、 JDBCTicketRegistry 、 JBOSS TreeCache 、 JpaTicketRegistry 、 MemcacheTicketRegistry 等； 支持多种客户端： Java 、 .Net 、 PHP 、 Perl 、 Apache, uPortal 等。 ##2. SSO 单点登录原理本文内容主要针对 Web SSO 。 2.1. 什么是SSO单点登录（ Single Sign-On , 简称 SSO ）是目前比较流行的服务于企业业务整合的解决方案之一， SSO 使得在多个应用系统中，用户只需要 登录一次 就可以访问所有相互信任的应用系统。 2.2. SSO 原理2.2.1. SSO 体系中的角色一般 SSO 体系主要角色有三种： User （多个） Web 应用（多个） SSO 认证中心（ 1 个 ） 2.2.2. SSO 实现模式的原则 所有的认证登录都在 SSO 认证中心进行； SSO 认证中心通过一些方法来告诉 Web 应用当前访问用户究竟是不是已通过认证的用户； SSO 认证中心和所有的 Web 应用建立一种信任关系，也就是说 web 应用必须信任认证中心。（单点信任） 2.2.3. SSO 主要实现方式 共享 cookies基于共享同域的 cookie 是 Web 刚开始阶段时使用的一种方式，它利用浏览同域名之间自动传递cookies机制，实现两个域名之间系统令牌传递问题；另外，关于跨域问题，虽然cookies 本身不跨域，但可以利用它实现跨域的 SSO。如：代理、暴露 SSO 令牌值等。缺点：不灵活而且有不少安全隐患，已经被抛弃。 Broker-based( 基于经纪人 )这种技术的特点就是，有一个集中的认证和用户帐号管理的服务器。经纪人给被用于进一步请求的电子身份存取。中央数据库的使用减少了管理的代价，并为认证提供一个公共和独立的 “ 第三方”。例如 Kerberos 、 Sesame 、 IBM KryptoKnight （凭证库思想 ) 等。 Kerberos 是由麻省理工大学发明的安全认证服务，已经被 UNIX 和 Windows作为默认的安全认证服务集成进操作系统。 Agent-based （基于代理人）在这种解决方案中，有一个自动地为不同的应用程序认证用户身份的代理程序。这个代理程序需要设计有不同的功能。比如，它可以使用口令表或加密密钥来自动地将认证的负担从用户移开。代理人被放在服务器上面，在服务器的认证系统和客户端认证方法之间充当一个 “ 翻译 “ 。例如 SSH 等。 Token-based例如 SecureID,WebID ，现在被广泛使用的口令认证，比如 FTP 、邮件服务器的登录认证，这是一种简单易用的方式，实现一个口令在多种应用当中使用。 基于网关 基于 SAML SAML(Security Assertion Markup Language ，安全断言标记语言）的出现大大简化了 SSO ，并被 OASIS 批准为 SSO 的执行标准 。开源组织 OpenSAML 实现了 SAML 规范。 3. CAS 的基本原理3.1. 结构体系从结构体系看， CAS 包括两部分： CAS Server 和 CAS Client 。 3.1.1. CAS ServerCAS Server 负责完成对用户的认证工作 , 需要独立部署 , CAS Server 会处理用户名 / 密码等凭证 (Credentials) 。 3.1.2. CAS Client负责处理对客户端受保护资源的访问请求，需要对请求方进行身份认证时，重定向到 CAS Server 进行认证。（原则上，客户端应用不再接受任何的用户名密码等 Credentials ）。CAS Client 与受保护的客户端应用部署在一起，以 Filter 方式保护受保护的资源。 3.2. CAS 原理和协议3.2.1. 基础模式 访问服务： SSO 客户端发送请求访问应用系统提供的服务资源。 定向认证： SSO 客户端会重定向用户请求到 SSO 服务器。 用户认证：用户身份认证。 发放票据： SSO 服务器会产生一个随机的 Service Ticket 。 验证票据： SSO 服务器验证票据 Service Ticket 的合法性，验证通过后，允许客户端访问服务。 传输用户信息： SSO 服务器验证票据通过后，传输用户认证结果信息给客户端。下面是 CAS 最基本的协议过程： cas基础协议图基础协议图 如上图： CAS Client 与受保护的客户端应用部署在一起，以 Filter 方式保护 Web 应用的受保护资源，过滤从客户端过来的每一个 Web 请求，同时， CAS Client 会分析 HTTP 请求中是否包含请求 Service Ticket( ST 上图中的 Ticket) ，如果没有，则说明该用户是没有经过认证的；于是 CAS Client 会重定向用户请求到 CAS Server （ Step 2 ），并传递 Service （要访问的目的资源地址）。 Step 3 是用户认证过程，如果用户提供了正确的 Credentials ， CAS Server 随机产生一个相当长度、唯一、不可伪造的 Service Ticket ，并缓存以待将来验证，并且重定向用户到 Service 所在地址（附带刚才产生的 Service Ticket ） , 并为客户端浏览器设置一个 Ticket Granted Cookie （ TGC ） ； CAS Client 在拿到 Service 和新产生的 Ticket 过后，在 Step 5 和 Step6 中与 CAS Server 进行身份核实，以确保 Service Ticket 的合法性。在该协议中，所有与 CAS Server 的交互均采用 SSL 协议，以确保 ST 和 TGC 的安全性。协议工作过程中会有 2 次重定向 的过程。但是 CAS Client 与 CAS Server 之间进行 Ticket 验证的过程对于用户是透明的（使用 HttpsURLConnection ）。 CAS 请求认证时序图如下： cas认证时序图 3.2.2. CAS 如何实现 SSO当用户访问另一个应用的服务再次被重定向到 CAS Server 的时候， CAS Server 会主动获到这个 TGC cookie ，然后做下面的事情： 1) 如果 User 持有 TGC 且其还没失效，那么就走基础协议图的 Step4 ，达到了 SSO 的效果； 2) 如果 TGC 失效，那么用户还是要重新认证 ( 走基础协议图的 Step3) 。 3.2.3. CAS 代理模式该模式形式为用户访问 App1 ， App1 又依赖于 App2 来获取一些信息，如： User –&gt;App1 –&gt;App2 。这种情况下，假设 App2 也是需要对 User 进行身份验证才能访问，那么，为了不影响用户体验（过多的重定向导致 User 的 IE 窗口不停地闪动 ) ， CAS 引入了一种 Proxy 认证机制，即 CAS Client 可以代理用户去访问其它 Web 应用。代理的前提是需要 CAS Client 拥有用户的身份信息 ( 类似凭据 ) 。之前我们提到的 TGC 是用户持有对自己身份信息的一种凭据，这里的 PGT 就是 CAS Client 端持有的对用户身份信息的一种凭据。凭借 TGC ， User 可以免去输入密码以获取访问其它服务的 Service Ticket ，所以，这里凭借 PGT ， Web 应用可以代理用户去实现后端的认证，而 无需前端用户的参与 。下面为代理应用（ helloService ）获取 PGT 的过程： （注： PGTURL 用于表示一个 Proxy 服务，是一个回调链接； PGT 相当于代理证； PGTIOU 为取代理证的钥匙，用来与 PGT 做关联关系；） 如上面的 CAS Proxy 图所示， CAS Client 在基础协议之上，在验证 ST 时提供了一个额外的 PGT URL( 而且是 SSL 的入口 ) 给 CAS Server ，使得 CAS Server 可以通过 PGT URL 提供一个 PGT 给 CAS Client 。CAS Client 拿到了 PGT(PGTIOU-85 … ..ti2td) ，就可以通过 PGT 向后端 Web 应用进行认证。下面是代理认证和提供服务的过程： 如上图所示， Proxy 认证与普通的认证其实差别不大， Step1 ， 2 与基础模式的 Step1,2 几乎一样，唯一不同的是， Proxy 模式用的是 PGT 而不是 TGC ，是 Proxy Ticket （ PT ）而不是 Service Ticket 。 3.2.4. 辅助说明CAS 的 SSO 实现方式可简化理解为： 1 个 Cookie 和 N 个 Session 。 CAS Server 创建 cookie ，在所有应用认证时使用，各应用通过创建各自的 Session 来标识用户是否已登录。用户在一个应用验证通过后，以后用户在同一浏览器里访问此应用时，客户端应用中的过滤器会在 session 里读取到用户信息，所以就不会去 CAS Server 认证。如果在此浏览器里访问别的 web 应用时，客户端应用中的过滤器在 session 里读取不到用户信息，就会去 CAS Server 的 login 接口认证，但这时 CAS Server 会读取到浏览器传来的 cookie （ TGC ），所以 CAS Server 不会要求用户去登录页面登录，只是会根据 service 参数生成一个 Ticket ，然后再和 web 应用做一个验证 ticket 的交互而已。 3.3. 术语解释CAS 系统中设计了 5 中票据： TGC 、 ST 、 PGT 、 PGTIOU 、 PT 。 Ticket-granting cookie(TGC) ：存放用户身份认证凭证的 cookie ，在浏览器和 CAS Server 间通讯时使用，并且只能基于安全通道传输（ Https ），是 CAS Server 用来明确用户身份的凭证； Service ticket(ST) ：服务票据，服务的惟一标识码 , 由 CAS Server 发出（ Http 传送），通过客户端浏览器到达业务服务器端；一个特定的服务只能有一个惟一的 ST ； Proxy-Granting ticket （ PGT ）：由 CAS Server 颁发给拥有 ST 凭证的服务， PGT 绑定一个用户的特定服务，使其拥有向 CAS Server 申请，获得 PT 的能力； Proxy-Granting Ticket I Owe You （ PGTIOU ） : 作用是将通过凭证校验时的应答信息由 CAS Server 返回给 CAS Client ，同时，与该 PGTIOU 对应的 PGT 将通过回调链接传给 Web 应用。 Web 应用负责维护 PGTIOU 与 PGT 之间映射关系的内容表； Proxy Ticket (PT) ：是应用程序代理用户身份对目标程序进行访问的凭证； 其它说明如下： Ticket Granting ticket(TGT) ：票据授权票据，由 KDC 的 AS 发放。即获取这样一张票据后，以后申请各种其他服务票据 (ST) 便不必再向 KDC 提交身份认证信息 (Credentials) ； Authentication service(AS) ——— 认证用服务，索取 Credentials ，发放 TGT ； Ticket-granting service (TGS) ——— 票据授权服务，索取 TGT ，发放 ST ； KDC( Key Distribution Center ) ———- 密钥发放中心； 4. CAS 安全性CAS 的安全性仅仅依赖于 SSL 。使用的是 secure cookie 。 4.1. TGC/PGT 安全性对于一个 CAS 用户来说，最重要是要保护它的 TGC ，如果 TGC 不慎被 CAS Server 以外的实体获得， Hacker 能够找到该 TGC ，然后冒充 CAS 用户访问 所有 授权资源。 PGT 的角色跟 TGC 是一样的。从基础模式可以看出， TGC 是 CAS Server 通过 SSL 方式发送给终端用户，因此，要截取 TGC 难度非常大，从而确保 CAS 的安全性。TGT 的存活周期默认为 120 分钟。 4.2. ST/PT 安全性ST （ Service Ticket ）是通过 Http 传送的，因此网络中的其他人可以 Sniffer 到其他人的 Ticket 。 CAS 通过以下几方面来使 ST 变得更加安全（事实上都是可以配置的）： ST 只能使用一次CAS 协议规定，无论 Service Ticket 验证是否成功， CAS Server 都会清除服务端缓存中的该 Ticket ，从而可以确保一个 Service Ticket 不被使用两次。 ST 在一段时间内失效CAS 规定 ST 只能存活一定的时间，然后 CAS Server 会让它失效。默认有效时间为 5 分钟。 ST 是基于随机数生成的ST 必须足够随机，如果 ST 生成规则被猜出， Hacker 就等于绕过 CAS 认证，直接访问 对应的 服务。 5. 参考资料 https://wiki.jasig.org/display/CASUM/Introduction http://www.jasig.org/cas/protocol/ http://www.ibm.com/developerworks/cn/opensource/os-cn-cas/index.html http://www.blogjava.net/security/archive/2006/10/02/sso_in_action.html http://baike.baidu.com/view/190743.htm]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于SQL的一些文章]]></title>
      <url>%2F2014%2F06%2F16%2Fsome-about-sql-article%2F</url>
      <content type="text"><![CDATA[画图解释SQL联合语句]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于正则的一些文章]]></title>
      <url>%2F2014%2F06%2F16%2Fsome-about-regular-article%2F</url>
      <content type="text"><![CDATA[浅析正则表达式——原理篇 浅析正则表达式——柳暗花明又一村篇]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS内置对象Object&Function]]></title>
      <url>%2F2014%2F04%2F25%2Fjavascript-function-object%2F</url>
      <content type="text"><![CDATA[###JS重要内容 内置对象：Object，Function protytype 上下文Context]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Intellij IDEA 快捷键整理&部分eclipse对应]]></title>
      <url>%2F2014%2F04%2F10%2FIntellij-IDEA-key-map%2F</url>
      <content type="text"><![CDATA[编辑 说明 Intellij IDEA Eclipse 显示文档 ctrl + Q 显示参数 Ctrl + P 显示最近编辑文件 Ctrl + E 代码完成 Ctrl + J 删除行 Ctrl + X Ctrl + d 复制行 Ctrl + D Ctrl+Alt+up/down 快速打开类 Ctrl + N 生成代码 Alt + Insert Alt + s + r 选择剪贴板内容并插入 Ctrl + Shift + Insert 可以快速打开文件 Ctrl + Shift + N 自动代码 Ctrl + J 两行转一行去空格 Ctrl + Shift + J 选择最近的剪贴板内容 Ctrl + Shift + V 查看继承层次结构 Ctrl + H 向上/下移动语句 Ctrl + Shift + Up / Down Alt + Up / Down 把代码包在一个块内 Ctrl + Alt + T 导入包，自动修正 Ctrl + Enter 格式化代码 Ctrl + Alt + L 格式化选中的代码 Ctrl + Alt + I 优化导入的类和包 Ctrl + Alt + O 导航 说明 Intellij IDEA Eclipse 最后编辑位置 Ctrl + Shift + Backspace Ctrl + Q 返回至上次浏览的位置 Ctrl + Alt + left / right 编辑页切换 Alt + Left / Right 跳转到语法错误代码处 F2 / Shift + F2 跳转到语法错误文件处 Ctrl + Alt + Up / Down 方法间快速移动 Alt + Up / Down 跳转到声明 Ctrl + B 条转到实现 Ctrl+ Alt + B 跳转到调用处 Ctrl Alt + F7 跳转到大括号开始/结尾 Ctrl+ [ / ] 最近的更改 Alt + Shift + C 跳到父类 Ctrl + U 查找/替换 说明 Intellij IDEA Eclipse 高亮显示选中文字 Ctrl + Shift + F7 F3向下;Shift+F3向上 Ctrl + K 替换文本 Ctrl + R 查找文本 Ctrl + F 全文查找 Ctrl + Shift + H ctrl + H 查找菜单功能 Ctrl + Shift + A 重构 说明 Intellij IDEA Eclipse 复制（文件） F5 移动（文件） F6 安全删除 Alt + Delete 重命名 Shift + F6 Ctrl + Shift + R Type Migration Ctrl + Shift + F6 抽取变量 Ctrl + Alt + V Alt + Shift + L 抽取方法 Ctrl + Alt + M 调试 说明 Intellij IDEA Eclipse 停止 Ctrl + F2 选择 Debug Alt + Shift + F9 选择 Run Alt + Shift + F10 编译 Ctrl + Shift + F9 运行 Ctrl + Shift + F10 查看断点 Ctrl + Shift + F8 步过 F8 步入 F7 智能步入 Shift + F7 步出 Shift + F8 强制步过 Alt + Shift + F8 强制步入 Alt + Shift + F7 运行至光标处 Alt + F9 强制运行至光标处 Ctrl + Alt + F9 恢复程序 F9 定位到断点 Alt + F10 切换行断点 Ctrl + F8 生成项目 Ctrl + F9 常用操作 说明 Intellij IDEA Eclipse 项目 Alt + 1 收藏 Alt + 2 TODO Alt + 6 结构 Alt + 7 复制路径 Ctrl + Shift + C 复制引用，必须选择类名 Ctrl+Alt + Shift + C 同步 Ctrl + Alt + Y 快速切换方案 Ctrl + ~ 还原默认布局 Shift + F12 隐藏/恢复所有窗口 Ctrl + Shift + F12 关闭 Ctrl + F4 关闭活动选项卡 Ctrl + Shift + F4 转到下一个拆分器 Ctrl + Tab 转到上一个拆分器 Ctrl + Shift + Tab 编译 Ctrl + Shift + F9 快速打开Commit Changes Ctrl + K 格式化1Ctrl + Alt + L 格式化代码]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Oracle 树结构递归简单用法]]></title>
      <url>%2F2014%2F04%2F03%2Foracle-tree-recursive%2F</url>
      <content type="text"><![CDATA[Oracle中树形结构的数据在查询时候比较麻烦，前不久看到同事有个用法觉得很不错，Oracle内置的，可以很便利的解决树递归查询问题 ###示例表结构 id name parent_id 1 aa 2 bb 1 3 cc 2 4 dd 3 ###从根节点到页节点 select * from table_ start with id = &apos;1&apos; connect by prior id=parent_id ###从叶节点到根节点 select * from table_ start with id = &apos;4&apos; connect by prior parent_id=id PIOR 位置运算符 PRIOR被放置于等号前后的位置，决定着查询时的检索顺序。 PRIOR被置于connect by子句中等号的前面时，则强制从根节点到叶节点的顺序检索，即由父节点向子节点方向通过树结构，我们称之为自顶向下 的方式。如： connect by prio id=parent_id PIROR运算符被置于connect by子句中等号的后面时，则强制从叶节点到根节点的顺序检索，即由子节点向父节点方向通过树结构，我们称之为自底向上 的方式。例如： connect by id=prio parent_id 在这种方式中也应指定一个开始的节点。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[杂项备忘]]></title>
      <url>%2F2014%2F03%2F21%2Fmark-and-memo%2F</url>
      <content type="text"><![CDATA[Intellij IDEA传说中的最智能java开发IDE。现在已经完全切换到IDEA上面来了。上一张IDEA快捷键图，没事来瞅瞅。 来一个[在线注册码生成器][1]，挺方便，本来社区版也够用，还是手贱下了商业版本。 PL/SQL Developer官方下载地址 Product Code：4t46t6vydkvsxekkvf3fjnpzy5wbuhphqz serial Number：601769 password：xs374ca Xmanager Enterprise 5注册码：101210-450789-147200 Dexpot一个类似linux多工作区的工具，挺方便，也很cool，来张图 Nikon Camera Control Pro 2 product key 48600-17854-11336-52282-35553 高清电影下载网站[中国高清网][2] 树莓派 开源硬件相关 openELEC KODI（XBMC） linux服务器环境一键安装包 OneinStack LNMP 看文章[简书][3] OSX 软件下载 macpeers AppKed xclient 爱情守望者 Intellij IDEA 在线注册Intellij IDEA [1]: http://174.140.163.89/keygen/idea.htm ‘Intellij IDEA’[2]: http://gaoqing.la ‘gaoqing’[3]: http://jianshu.io ‘jianshu’]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[艺术 生活]]></title>
      <url>%2F2014%2F03%2F11%2Fart-life%2F</url>
      <content type="text"><![CDATA[艺术就是生活的浓缩与提炼,它有时会把一些生活中的东西做的更纯粹,更极致。它是美的，纯粹的，带着创作者的个人倾向，必定是展现，提取他认为有价值的东西。就这一点说，比起日常的纷繁复杂，良莠不齐是高了。或许不是很准确，但举个例子 ，文学上各种修辞手法的运用，就使得作品与现实有了差异，更强烈，更震撼，等等。 人生如戏 全靠演技有人说人生如戏,我说人生就是一场戏而已,你我都是主角,都在用自己的方式演绎.如果一个女人把自己超过三分之一的时间用在了你身上,那么请姑且相信,这个女人爱你.哪怕她在演戏,她还在和其他男人暧昧,她还在和其他男人选择和被选择地演戏,她还在挂,还在挑,还在选.能花三分之一的时间在你身上,就是真的. 同样的道理,如果一个男人把自己超过三分之一的总收入用在了你身上,那么姑且请相信,这个男人爱你.哪怕他在演戏,他要考虑他的实际收入,他要消费,他要储蓄,他要应酬,能花三分之一收入在你身上,那就是真的. 没有多少男人会泡MM了,这个年头,男人负担太重,活得太累.所以,即便一个男人想泡你,他也是真心在泡你.如果只是为了性,这个年头可以解决的途径和方式很多,很直接迅速廉价.所以女人们无需异想天开,你们的身体并没有你们想像的那么令人神往. 没有多少女人会真心在男人身上花时间了,现在女人都功利,现实,如果你不是千万富翁,就别以为女人是贪你的钱财.何况这个年头,女人想赚钱,途径很多,方法很多,也很直接迅速.所以男人们无需异想天开,没几个女人会在意你们那几个小钱.所以,泡你的人,和陪你的人,都是在真心地逢场作戏,至少他们还相信爱情,还期待爱情,还很纯真,还很善良. 那些为你赶路,为你计划,为你安排,为你消费的男人,请你珍惜.也许他们并不富裕,但愿意为你花费一周乃至数周的薪水,博你一笑,和彼此的开心快乐,那么他是爱你的,他是一个有道德的人,他演技高超.那些为你化妆,为你精心准备服饰,为你推掉应酬约会,在青春的岁月里陪你的女人,请你珍惜.也许她们并不国色天香,气质高雅,但是甘愿在人生最宝贵的时间陪伴你,让你不寂寞,让彼此愉悦,那么她是爱你的,她成功欺骗了你,欺骗了自己. 也许你不相信爱情,也许你不能再爱,也许你觉得世界庸俗,也许你觉得没有什么可以相信.请相信这一切都是真的.那个男人深夜里给你发来信息和问候,在很多时间牵挂着你,哪怕他在莺莺燕燕的包围里,只要他还记得你,那其实就是真实的爱. 很多人似乎看透人世,也许你觉得这个世界很物质,这个世界很残酷,这个世界没有真爱,这个世界虚伪,这个人生虚幻,请相信这一切都是真的,因为世界原本如此.那个女人跟朋友聊天会谈到你,在睡前想到你会笑,哪怕第二天她要赶赴其他男人的约会,只要她还念着你. 不知道谁还会为我演戏,我还会为谁演戏.无论如何都应该善待那个真心欺骗你的人,请珍惜为你演戏的人,因为他/她至少为你演过戏. 我的看法要扮演好自己在生活当中的角色，这就是所谓的演技吧，努力使自己的生活更加美好那便是艺术了吧。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于我]]></title>
      <url>%2F2014%2F03%2F09%2Fabout-me%2F</url>
      <content type="text"><![CDATA[JEE 6年研发，熟悉Spring，Mybatis，Hibernate，Shiro，Quartz，Ehcache，Lucene，Solr，Elasticsearch，Activiti，Redis，Oracle，Mysql，H2，Html，Css，Javascript，Jquery，Bootstrap，Tomcat，Linux,Docker]]></content>
    </entry>

    
  
  
</search>
